{
  "version": 3,
  "sources": ["browser-external:os", "../../hjson/lib/hjson-common.js", "../../hjson/lib/hjson-version.js", "../../hjson/lib/hjson-dsf.js", "../../hjson/lib/hjson-parse.js", "../../hjson/lib/hjson-stringify.js", "../../hjson/lib/hjson-comments.js", "../../hjson/lib/hjson.js"],
  "sourcesContent": ["module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"os\" has been externalized for browser compatibility. Cannot access \"os.${key}\" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "/* Hjson https://hjson.github.io */\n\"use strict\";\n\nvar os=require('os'); // will be {} when used in a browser\n\nfunction tryParseNumber(text, stopAtNext) {\n\n  // try to parse a number\n\n  var number, string = '', leadingZeros = 0, testLeading = true;\n  var at = 0;\n  var ch;\n  function next() {\n    ch = text.charAt(at);\n    at++;\n    return ch;\n  }\n\n  next();\n  if (ch === '-') {\n    string = '-';\n    next();\n  }\n  while (ch >= '0' && ch <= '9') {\n    if (testLeading) {\n      if (ch == '0') leadingZeros++;\n      else testLeading = false;\n    }\n    string += ch;\n    next();\n  }\n  if (testLeading) leadingZeros--; // single 0 is allowed\n  if (ch === '.') {\n    string += '.';\n    while (next() && ch >= '0' && ch <= '9')\n      string += ch;\n  }\n  if (ch === 'e' || ch === 'E') {\n    string += ch;\n    next();\n    if (ch === '-' || ch === '+') {\n      string += ch;\n      next();\n    }\n    while (ch >= '0' && ch <= '9') {\n      string += ch;\n      next();\n    }\n  }\n\n  // skip white/to (newline)\n  while (ch && ch <= ' ') next();\n\n  if (stopAtNext) {\n    // end scan if we find a punctuator character like ,}] or a comment\n    if (ch === ',' || ch === '}' || ch === ']' ||\n      ch === '#' || ch === '/' && (text[at] === '/' || text[at] === '*')) ch = 0;\n  }\n\n  number = +string;\n  if (ch || leadingZeros || !isFinite(number)) return undefined;\n  else return number;\n}\n\nfunction createComment(value, comment) {\n  if (Object.defineProperty) Object.defineProperty(value, \"__COMMENTS__\", { enumerable: false, writable: true });\n  return (value.__COMMENTS__ = comment||{});\n}\n\nfunction removeComment(value) {\n  Object.defineProperty(value, \"__COMMENTS__\", { value: undefined });\n}\n\nfunction getComment(value) {\n  return value.__COMMENTS__;\n}\n\nfunction forceComment(text) {\n  if (!text) return \"\";\n  var a = text.split('\\n');\n  var str, i, j, len;\n  for (j = 0; j < a.length; j++) {\n    str = a[j];\n    len = str.length;\n    for (i = 0; i < len; i++) {\n      var c = str[i];\n      if (c === '#') break;\n      else if (c === '/' && (str[i+1] === '/' || str[i+1] === '*')) {\n        if (str[i+1] === '*') j = a.length; // assume /**/ covers whole block, bail out\n        break;\n      }\n      else if (c > ' ') {\n        a[j] = '# ' + str;\n        break;\n      }\n    }\n  }\n  return a.join('\\n');\n}\n\nmodule.exports = {\n  EOL: os.EOL || '\\n',\n  tryParseNumber: tryParseNumber,\n  createComment: createComment,\n  removeComment: removeComment,\n  getComment: getComment,\n  forceComment: forceComment,\n};\n", "module.exports=\"3.2.1\";\n", "/* Hjson https://hjson.github.io */\n\"use strict\";\n\nfunction loadDsf(col, type) {\n\n  if (Object.prototype.toString.apply(col) !== '[object Array]') {\n    if (col) throw new Error(\"dsf option must contain an array!\");\n    else return nopDsf;\n  } else if (col.length === 0) return nopDsf;\n\n  var dsf = [];\n  function isFunction(f) { return {}.toString.call(f) === '[object Function]'; }\n\n  col.forEach(function(x) {\n    if (!x.name || !isFunction(x.parse) || !isFunction(x.stringify))\n      throw new Error(\"extension does not match the DSF interface\");\n    dsf.push(function() {\n      try {\n        if (type == \"parse\") {\n          return x.parse.apply(null, arguments);\n        } else if (type == \"stringify\") {\n          var res=x.stringify.apply(null, arguments);\n          // check result\n          if (res !== undefined && (typeof res !== \"string\" ||\n            res.length === 0 ||\n            res[0] === '\"' ||\n            [].some.call(res, function(c) { return isInvalidDsfChar(c); })))\n            throw new Error(\"value may not be empty, start with a quote or contain a punctuator character except colon: \" + res);\n          return res;\n        } else throw new Error(\"Invalid type\");\n      } catch (e) {\n        throw new Error(\"DSF-\"+x.name+\" failed; \"+e.message);\n      }\n    });\n  });\n\n  return runDsf.bind(null, dsf);\n}\n\nfunction runDsf(dsf, value) {\n  if (dsf) {\n    for (var i = 0; i < dsf.length; i++) {\n      var res = dsf[i](value);\n      if (res !== undefined) return res;\n    }\n  }\n}\n\nfunction nopDsf(/*value*/) {\n}\n\nfunction isInvalidDsfChar(c) {\n  return c === '{' || c === '}' || c === '[' || c === ']' || c === ',';\n}\n\n\nfunction math(/*opt*/) {\n  return {\n    name: \"math\",\n    parse: function (value) {\n      switch (value) {\n        case \"+inf\":\n        case \"inf\":\n        case \"+Inf\":\n        case \"Inf\": return Infinity;\n        case \"-inf\":\n        case \"-Inf\": return -Infinity;\n        case \"nan\":\n        case \"NaN\": return NaN;\n      }\n    },\n    stringify: function (value) {\n      if (typeof value !== 'number') return;\n      if (1 / value === -Infinity) return \"-0\"; // 0 === -0\n      if (value === Infinity) return \"Inf\";\n      if (value === -Infinity) return \"-Inf\";\n      if (isNaN(value)) return \"NaN\";\n    },\n  };\n}\nmath.description=\"support for Inf/inf, -Inf/-inf, Nan/naN and -0\";\n\nfunction hex(opt) {\n  var out=opt && opt.out;\n  return {\n    name: \"hex\",\n    parse: function (value) {\n      if (/^0x[0-9A-Fa-f]+$/.test(value))\n        return parseInt(value, 16);\n    },\n    stringify: function (value) {\n      if (out && Number.isInteger(value))\n        return \"0x\"+value.toString(16);\n    },\n  };\n}\nhex.description=\"parse hexadecimal numbers prefixed with 0x\";\n\nfunction date(/*opt*/) {\n  return {\n    name: \"date\",\n    parse: function (value) {\n      if (/^\\d{4}-\\d{2}-\\d{2}$/.test(value) ||\n        /^\\d{4}-\\d{2}-\\d{2}T\\d{2}\\:\\d{2}\\:\\d{2}(?:.\\d+)(?:Z|[+-]\\d{2}:\\d{2})$/.test(value)) {\n        var dt = Date.parse(value);\n        if (!isNaN(dt)) return new Date(dt);\n      }\n    },\n    stringify: function (value) {\n      if (Object.prototype.toString.call(value) === '[object Date]') {\n        var dt = value.toISOString();\n        if (dt.indexOf(\"T00:00:00.000Z\", dt.length - 14) !== -1) return dt.substr(0, 10);\n        else return dt;\n      }\n    },\n  };\n}\ndate.description=\"support ISO dates\";\n\nmodule.exports = {\n  loadDsf: loadDsf,\n  std: {\n    math: math,\n    hex: hex,\n    date: date,\n  },\n};\n", "/* Hjson https://hjson.github.io */\n\"use strict\";\n\nmodule.exports = function(source, opt) {\n\n  var common = require(\"./hjson-common\");\n  var dsf = require(\"./hjson-dsf\");\n\n  var text;\n  var at;   // The index of the current character\n  var ch;   // The current character\n  var escapee = {\n    '\"': '\"',\n    \"'\": \"'\",\n    '\\\\': '\\\\',\n    '/': '/',\n    b:  '\\b',\n    f:  '\\f',\n    n:  '\\n',\n    r:  '\\r',\n    t:  '\\t'\n  };\n\n  var keepComments;\n  var runDsf; // domain specific formats\n\n  function resetAt() {\n    at = 0;\n    ch = ' ';\n  }\n\n  function isPunctuatorChar(c) {\n    return c === '{' || c === '}' || c === '[' || c === ']' || c === ',' || c === ':';\n  }\n\n  // Call error when something is wrong.\n  function error(m) {\n    var i, col=0, line=1;\n    for (i = at-1; i > 0 && text[i] !== '\\n'; i--, col++) {}\n    for (; i > 0; i--) if (text[i] === '\\n') line++;\n    throw new Error(m + \" at line \" + line + \",\" + col + \" >>>\" + text.substr(at-col, 20) + \" ...\");\n  }\n\n  function next() {\n    // get the next character.\n    ch = text.charAt(at);\n    at++;\n    return ch;\n  }\n\n  function peek(offs) {\n    // range check is not required\n    return text.charAt(at + offs);\n  }\n\n  function string(allowML) {\n    // Parse a string value.\n    // callers make sure that (ch === '\"' || ch === \"'\")\n    var string = '';\n\n    // When parsing for string values, we must look for \"/' and \\ characters.\n    var exitCh = ch;\n    while (next()) {\n      if (ch === exitCh) {\n        next();\n        if (allowML && exitCh === \"'\" && ch === \"'\" && string.length === 0) {\n          // ''' indicates a multiline string\n          next();\n          return mlString();\n        } else return string;\n      }\n      if (ch === '\\\\') {\n        next();\n        if (ch === 'u') {\n          var uffff = 0;\n          for (var i = 0; i < 4; i++) {\n            next();\n            var c = ch.charCodeAt(0), hex;\n            if (ch >= '0' && ch <= '9') hex = c - 48;\n            else if (ch >= 'a' && ch <= 'f') hex = c - 97 + 0xa;\n            else if (ch >= 'A' && ch <= 'F') hex = c - 65 + 0xa;\n            else error(\"Bad \\\\u char \" + ch);\n            uffff = uffff * 16 + hex;\n          }\n          string += String.fromCharCode(uffff);\n        } else if (typeof escapee[ch] === 'string') {\n          string += escapee[ch];\n        } else break;\n      } else if (ch === '\\n' || ch === '\\r') {\n        error(\"Bad string containing newline\");\n      } else {\n        string += ch;\n      }\n    }\n    error(\"Bad string\");\n  }\n\n  function mlString() {\n    // Parse a multiline string value.\n    var string = '', triple = 0;\n\n    // we are at ''' +1 - get indent\n    var indent = 0;\n    for (;;) {\n      var c=peek(-indent-5);\n      if (!c || c === '\\n') break;\n      indent++;\n    }\n\n    function skipIndent() {\n      var skip = indent;\n      while (ch && ch <= ' ' && ch !== '\\n' && skip-- > 0) next();\n    }\n\n    // skip white/to (newline)\n    while (ch && ch <= ' ' && ch !== '\\n') next();\n    if (ch === '\\n') { next(); skipIndent(); }\n\n    // When parsing multiline string values, we must look for ' characters.\n    for (;;) {\n      if (!ch) {\n        error(\"Bad multiline string\");\n      } else if (ch === '\\'') {\n        triple++;\n        next();\n        if (triple === 3) {\n          if (string.slice(-1) === '\\n') string=string.slice(0, -1); // remove last EOL\n          return string;\n        } else continue;\n      } else {\n        while (triple > 0) {\n          string += '\\'';\n          triple--;\n        }\n      }\n      if (ch === '\\n') {\n        string += '\\n';\n        next();\n        skipIndent();\n      } else {\n        if (ch !== '\\r') string += ch;\n        next();\n      }\n    }\n  }\n\n  function keyname() {\n    // quotes for keys are optional in Hjson\n    // unless they include {}[],: or whitespace.\n\n    if (ch === '\"' || ch === \"'\") return string(false);\n\n    var name = \"\", start = at, space = -1;\n    for (;;) {\n      if (ch === ':') {\n        if (!name) error(\"Found ':' but no key name (for an empty key name use quotes)\");\n        else if (space >=0 && space !== name.length) { at = start + space; error(\"Found whitespace in your key name (use quotes to include)\"); }\n        return name;\n      } else if (ch <= ' ') {\n        if (!ch) error(\"Found EOF while looking for a key name (check your syntax)\");\n        else if (space < 0) space = name.length;\n      } else if (isPunctuatorChar(ch)) {\n        error(\"Found '\" + ch + \"' where a key name was expected (check your syntax or use quotes if the key name includes {}[],: or whitespace)\");\n      } else {\n        name += ch;\n      }\n      next();\n    }\n  }\n\n  function white() {\n    while (ch) {\n      // Skip whitespace.\n      while (ch && ch <= ' ') next();\n      // Hjson allows comments\n      if (ch === '#' || ch === '/' && peek(0) === '/') {\n        while (ch && ch !== '\\n') next();\n      } else if (ch === '/' && peek(0) === '*') {\n        next(); next();\n        while (ch && !(ch === '*' && peek(0) === '/')) next();\n        if (ch) { next(); next(); }\n      } else break;\n    }\n  }\n\n  function tfnns() {\n    // Hjson strings can be quoteless\n    // returns string, true, false, or null.\n    var value = ch;\n    if (isPunctuatorChar(ch))\n      error(\"Found a punctuator character '\" + ch + \"' when expecting a quoteless string (check your syntax)\");\n\n    for(;;) {\n      next();\n      // (detection of ml strings was moved to string())\n      var isEol = ch === '\\r' || ch === '\\n' || ch === '';\n      if (isEol ||\n        ch === ',' || ch === '}' || ch === ']' ||\n        ch === '#' ||\n        ch === '/' && (peek(0) === '/' || peek(0) === '*')\n        ) {\n        // this tests for the case of {true|false|null|num}\n        // followed by { ',' | '}' | ']' | '#' | '//' | '/*' }\n        // which needs to be parsed as the specified value\n        var chf = value[0];\n        switch (chf) {\n          case 'f': if (value.trim() === \"false\") return false; break;\n          case 'n': if (value.trim() === \"null\") return null; break;\n          case 't': if (value.trim() === \"true\") return true; break;\n          default:\n            if (chf === '-' || chf >= '0' && chf <= '9') {\n              var n = common.tryParseNumber(value);\n              if (n !== undefined) return n;\n            }\n        }\n        if (isEol) {\n          // remove any whitespace at the end (ignored in quoteless strings)\n          value = value.trim();\n          var dsfValue = runDsf(value);\n          return dsfValue !== undefined ? dsfValue : value;\n        }\n      }\n      value += ch;\n    }\n  }\n\n  function getComment(cAt, first) {\n    var i;\n    cAt--;\n    // remove trailing whitespace\n    // but only up to EOL\n    for (i = at - 2; i > cAt && text[i] <= ' ' && text[i] !== '\\n'; i--);\n    if (text[i] === '\\n') i--;\n    if (text[i] === '\\r') i--;\n    var res = text.substr(cAt, i-cAt+1);\n    // return if we find anything other than whitespace\n    for (i = 0; i < res.length; i++) {\n      if (res[i] > ' ') {\n        var j = res.indexOf('\\n');\n        if (j >= 0) {\n          var c = [res.substr(0, j), res.substr(j+1)];\n          if (first && c[0].trim().length === 0) c.shift();\n          return c;\n        } else return [res];\n      }\n    }\n    return [];\n  }\n\n  function errorClosingHint(value) {\n    function search(value, ch) {\n      var i, k, length, res;\n      switch (typeof value) {\n        case 'string':\n          if (value.indexOf(ch) >= 0) res = value;\n          break;\n        case 'object':\n          if (Object.prototype.toString.apply(value) === '[object Array]') {\n            for (i = 0, length = value.length; i < length; i++) {\n              res=search(value[i], ch) || res;\n            }\n          } else {\n            for (k in value) {\n              if (!Object.prototype.hasOwnProperty.call(value, k)) continue;\n              res=search(value[k], ch) || res;\n            }\n          }\n      }\n      return res;\n    }\n\n    function report(ch) {\n      var possibleErr=search(value, ch);\n      if (possibleErr) {\n        return \"found '\"+ch+\"' in a string value, your mistake could be with:\\n\"+\n          \"  > \"+possibleErr+\"\\n\"+\n          \"  (unquoted strings contain everything up to the next line!)\";\n      } else return \"\";\n    }\n\n    return report('}') || report(']');\n  }\n\n  function array() {\n    // Parse an array value.\n    // assuming ch === '['\n\n    var array = [];\n    var comments, cAt, nextComment;\n    try {\n      if (keepComments) comments = common.createComment(array, { a: [] });\n\n      next();\n      cAt = at;\n      white();\n      if (comments) nextComment = getComment(cAt, true).join('\\n');\n      if (ch === ']') {\n        next();\n        if (comments) comments.e = [nextComment];\n        return array;  // empty array\n      }\n\n      while (ch) {\n        array.push(value());\n        cAt = at;\n        white();\n        // in Hjson the comma is optional and trailing commas are allowed\n        // note that we do not keep comments before the , if there are any\n        if (ch === ',') { next(); cAt = at; white(); }\n        if (comments) {\n          var c = getComment(cAt);\n          comments.a.push([nextComment||\"\", c[0]||\"\"]);\n          nextComment = c[1];\n        }\n        if (ch === ']') {\n          next();\n          if (comments) comments.a[comments.a.length-1][1] += nextComment||\"\";\n          return array;\n        }\n        white();\n      }\n\n      error(\"End of input while parsing an array (missing ']')\");\n    } catch (e) {\n      e.hint=e.hint||errorClosingHint(array);\n      throw e;\n    }\n  }\n\n  function object(withoutBraces) {\n    // Parse an object value.\n\n    var key = \"\", object = {};\n    var comments, cAt, nextComment;\n\n    try {\n      if (keepComments) comments = common.createComment(object, { c: {}, o: []  });\n\n      if (!withoutBraces) {\n        // assuming ch === '{'\n        next();\n        cAt = at;\n      } else cAt = 1;\n\n      white();\n      if (comments) nextComment = getComment(cAt, true).join('\\n');\n      if (ch === '}' && !withoutBraces) {\n        if (comments) comments.e = [nextComment];\n        next();\n        return object;  // empty object\n      }\n      while (ch) {\n        key = keyname();\n        white();\n        if (ch !== ':') error(\"Expected ':' instead of '\" + ch + \"'\");\n        next();\n        // duplicate keys overwrite the previous value\n        object[key] = value();\n        cAt = at;\n        white();\n        // in Hjson the comma is optional and trailing commas are allowed\n        // note that we do not keep comments before the , if there are any\n        if (ch === ',') { next(); cAt = at; white(); }\n        if (comments) {\n          var c = getComment(cAt);\n          comments.c[key] = [nextComment||\"\", c[0]||\"\"];\n          nextComment = c[1];\n          comments.o.push(key);\n        }\n        if (ch === '}' && !withoutBraces) {\n          next();\n          if (comments) comments.c[key][1] += nextComment||\"\";\n          return object;\n        }\n        white();\n      }\n\n      if (withoutBraces) return object;\n      else error(\"End of input while parsing an object (missing '}')\");\n    } catch (e) {\n      e.hint=e.hint||errorClosingHint(object);\n      throw e;\n    }\n  }\n\n  function value() {\n    // Parse a Hjson value. It could be an object, an array, a string, a number or a word.\n\n    white();\n    switch (ch) {\n      case '{': return object();\n      case '[': return array();\n      case \"'\":\n      case '\"': return string(true);\n      default: return tfnns();\n    }\n  }\n\n  function checkTrailing(v, c) {\n    var cAt = at;\n    white();\n    if (ch) error(\"Syntax error, found trailing characters\");\n    if (keepComments) {\n      var b = c.join('\\n'), a = getComment(cAt).join('\\n');\n      if (a || b) {\n        var comments = common.createComment(v, common.getComment(v));\n        comments.r = [b, a];\n      }\n    }\n    return v;\n  }\n\n  function rootValue() {\n    white();\n    var c = keepComments ? getComment(1) : null;\n    switch (ch) {\n      case '{': return checkTrailing(object(), c);\n      case '[': return checkTrailing(array(), c);\n      default: return checkTrailing(value(), c);\n    }\n  }\n\n  function legacyRootValue() {\n    // Braces for the root object are optional\n    white();\n    var c = keepComments ? getComment(1) : null;\n    switch (ch) {\n      case '{': return checkTrailing(object(), c);\n      case '[': return checkTrailing(array(), c);\n    }\n\n    try {\n      // assume we have a root object without braces\n      return checkTrailing(object(true), c);\n    } catch (e) {\n      // test if we are dealing with a single JSON value instead (true/false/null/num/\"\")\n      resetAt();\n      try { return checkTrailing(value(), c); }\n      catch (e2) { throw e; } // throw original error\n    }\n  }\n\n  if (typeof source!==\"string\") throw new Error(\"source is not a string\");\n  var dsfDef = null;\n  var legacyRoot = true;\n  if (opt && typeof opt === 'object') {\n    keepComments = opt.keepWsc;\n    dsfDef = opt.dsf;\n    legacyRoot = opt.legacyRoot !== false; // default true\n  }\n  runDsf = dsf.loadDsf(dsfDef, \"parse\");\n  text = source;\n  resetAt();\n  return legacyRoot ? legacyRootValue() : rootValue();\n};\n", "/* Hjson https://hjson.github.io */\n\"use strict\";\n\nmodule.exports = function(data, opt) {\n\n  var common = require(\"./hjson-common\");\n  var dsf = require(\"./hjson-dsf\");\n\n  var plainToken = {\n    obj:  [ '{', '}' ],\n    arr:  [ '[', ']' ],\n    key:  [ '',  '' ],\n    qkey: [ '\"', '\"' ],\n    col:  [ ':', '' ],\n    com:  [ ',', '' ],\n    str:  [ '', '' ],\n    qstr: [ '\"', '\"' ],\n    mstr: [ \"'''\", \"'''\" ],\n    num:  [ '', '' ],\n    lit:  [ '', '' ],\n    dsf:  [ '', '' ],\n    esc:  [ '\\\\', '' ],\n    uni:  [ '\\\\u', '' ],\n    rem:  [ '', '' ],\n  };\n\n  // options\n  var eol = common.EOL;\n  var indent = '  ';\n  var keepComments = false;\n  var bracesSameLine = false;\n  var quoteKeys = false;\n  var quoteStrings = false;\n  var condense = 0;\n  var multiline = 1; // std=1, no-tabs=2, off=0\n  var separator = ''; // comma separator\n  var dsfDef = null;\n  var sortProps = false;\n  var token = plainToken;\n\n  if (opt && typeof opt === 'object') {\n    opt.quotes = opt.quotes === 'always' ? 'strings' : opt.quotes; // legacy\n\n    if (opt.eol === '\\n' || opt.eol === '\\r\\n') eol = opt.eol;\n    keepComments = opt.keepWsc;\n    condense = opt.condense || 0;\n    bracesSameLine = opt.bracesSameLine;\n    quoteKeys = opt.quotes === 'all' || opt.quotes === 'keys';\n    quoteStrings = opt.quotes === 'all' || opt.quotes === 'strings' || opt.separator === true;\n    if (quoteStrings || opt.multiline == 'off') multiline = 0;\n    else multiline = opt.multiline == 'no-tabs' ? 2 : 1;\n    separator = opt.separator === true ? token.com[0] : '';\n    dsfDef = opt.dsf;\n    sortProps = opt.sortProps;\n\n    // If the space parameter is a number, make an indent string containing that\n    // many spaces. If it is a string, it will be used as the indent string.\n\n    if (typeof opt.space === 'number') {\n      indent = new Array(opt.space + 1).join(' ');\n    } else if (typeof opt.space === 'string') {\n      indent = opt.space;\n    }\n\n    if (opt.colors === true) {\n      token = {\n        obj:  [ '\\x1b[37m{\\x1b[0m', '\\x1b[37m}\\x1b[0m' ],\n        arr:  [ '\\x1b[37m[\\x1b[0m', '\\x1b[37m]\\x1b[0m' ],\n        key:  [ '\\x1b[33m',  '\\x1b[0m' ],\n        qkey: [ '\\x1b[33m\"', '\"\\x1b[0m' ],\n        col:  [ '\\x1b[37m:\\x1b[0m', '' ],\n        com:  [ '\\x1b[37m,\\x1b[0m', '' ],\n        str:  [ '\\x1b[37;1m', '\\x1b[0m' ],\n        qstr: [ '\\x1b[37;1m\"', '\"\\x1b[0m' ],\n        mstr: [ \"\\x1b[37;1m'''\", \"'''\\x1b[0m\" ],\n        num:  [ '\\x1b[36;1m', '\\x1b[0m' ],\n        lit:  [ '\\x1b[36m', '\\x1b[0m' ],\n        dsf:  [ '\\x1b[37m', '\\x1b[0m' ],\n        esc:  [ '\\x1b[31m\\\\', '\\x1b[0m' ],\n        uni:  [ '\\x1b[31m\\\\u', '\\x1b[0m' ],\n        rem:  [ '\\x1b[35m', '\\x1b[0m' ],\n      };\n    }\n\n    var i, ckeys=Object.keys(plainToken);\n    for (i = ckeys.length - 1; i >= 0; i--) {\n      var k = ckeys[i];\n      token[k].push(plainToken[k][0].length, plainToken[k][1].length);\n    }\n  }\n\n  //\n  var runDsf; // domain specific formats\n\n  var commonRange='\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff';\n  // needsEscape tests if the string can be written without escapes\n  var needsEscape = new RegExp('[\\\\\\\\\\\\\"\\x00-\\x1f'+commonRange+']', 'g');\n  // needsQuotes tests if the string can be written as a quoteless string (like needsEscape but without \\\\ and \\\")\n  var needsQuotes = new RegExp('^\\\\s|^\"|^\\'|^#|^\\\\/\\\\*|^\\\\/\\\\/|^\\\\{|^\\\\}|^\\\\[|^\\\\]|^:|^,|\\\\s$|[\\x00-\\x1f'+commonRange+']', 'g');\n  // needsEscapeML tests if the string can be written as a multiline string (like needsEscape but without \\n, \\r, \\\\, \\\", \\t unless multines is 'std')\n  var needsEscapeML = new RegExp('\\'\\'\\'|^[\\\\s]+$|[\\x00-'+(multiline === 2 ? '\\x09' : '\\x08')+'\\x0b\\x0c\\x0e-\\x1f'+commonRange+']', 'g');\n  // starts with a keyword and optionally is followed by a comment\n  var startsWithKeyword = new RegExp('^(true|false|null)\\\\s*((,|\\\\]|\\\\}|#|//|/\\\\*).*)?$');\n  var meta = {\n    // table of character substitutions\n    '\\b': 'b',\n    '\\t': 't',\n    '\\n': 'n',\n    '\\f': 'f',\n    '\\r': 'r',\n    '\"' : '\"',\n    '\\\\': '\\\\'\n  };\n  var needsEscapeName = /[,\\{\\[\\}\\]\\s:#\"']|\\/\\/|\\/\\*/;\n  var gap = '';\n  //\n  var wrapLen = 0;\n\n  function wrap(tk, v) {\n    wrapLen += tk[0].length + tk[1].length - tk[2] - tk[3];\n    return tk[0] + v + tk[1];\n  }\n\n  function quoteReplace(string) {\n    return string.replace(needsEscape, function (a) {\n      var c = meta[a];\n      if (typeof c === 'string') return wrap(token.esc, c);\n      else return wrap(token.uni, ('0000' + a.charCodeAt(0).toString(16)).slice(-4));\n    });\n  }\n\n  function quote(string, gap, hasComment, isRootObject) {\n    if (!string) return wrap(token.qstr, '');\n\n    needsQuotes.lastIndex = 0;\n    startsWithKeyword.lastIndex = 0;\n\n    // Check if we can insert this string without quotes\n    // see hjson syntax (must not parse as true, false, null or number)\n\n    if (quoteStrings || hasComment ||\n      needsQuotes.test(string) ||\n      common.tryParseNumber(string, true) !== undefined ||\n      startsWithKeyword.test(string)) {\n\n      // If the string contains no control characters, no quote characters, and no\n      // backslash characters, then we can safely slap some quotes around it.\n      // Otherwise we first check if the string can be expressed in multiline\n      // format or we must replace the offending characters with safe escape\n      // sequences.\n\n      needsEscape.lastIndex = 0;\n      needsEscapeML.lastIndex = 0;\n      if (!needsEscape.test(string)) return wrap(token.qstr, string);\n      else if (!needsEscapeML.test(string) && !isRootObject && multiline) return mlString(string, gap);\n      else return wrap(token.qstr, quoteReplace(string));\n    } else {\n      // return without quotes\n      return wrap(token.str, string);\n    }\n  }\n\n  function mlString(string, gap) {\n    // wrap the string into the ''' (multiline) format\n\n    var i, a = string.replace(/\\r/g, \"\").split('\\n');\n    gap += indent;\n\n    if (a.length === 1) {\n      // The string contains only a single line. We still use the multiline\n      // format as it avoids escaping the \\ character (e.g. when used in a\n      // regex).\n      return wrap(token.mstr, a[0]);\n    } else {\n      var res = eol + gap + token.mstr[0];\n      for (i = 0; i < a.length; i++) {\n        res += eol;\n        if (a[i]) res += gap + a[i];\n      }\n      return res + eol + gap + token.mstr[1];\n    }\n  }\n\n  function quoteKey(name) {\n    if (!name) return '\"\"';\n\n    // Check if we can insert this key without quotes\n\n    if (quoteKeys || needsEscapeName.test(name)) {\n      needsEscape.lastIndex = 0;\n      return wrap(token.qkey, needsEscape.test(name) ? quoteReplace(name) : name);\n    } else {\n      // return without quotes\n      return wrap(token.key, name);\n    }\n  }\n\n  function str(value, hasComment, noIndent, isRootObject) {\n    // Produce a string from value.\n\n    function startsWithNL(str) { return str && str[str[0] === '\\r' ? 1 : 0] === '\\n'; }\n    function commentOnThisLine(str) { return str && !startsWithNL(str); }\n    function makeComment(str, prefix, trim) {\n      if (!str) return \"\";\n      str = common.forceComment(str);\n      var i, len = str.length;\n      for (i = 0; i < len && str[i] <= ' '; i++) {}\n      if (trim && i > 0) str = str.substr(i);\n      if (i < len) return prefix + wrap(token.rem, str);\n      else return str;\n    }\n\n    // What happens next depends on the value's type.\n\n    // check for DSF\n    var dsfValue = runDsf(value);\n    if (dsfValue !== undefined) return wrap(token.dsf, dsfValue);\n\n    switch (typeof value) {\n      case 'string':\n        return quote(value, gap, hasComment, isRootObject);\n\n      case 'number':\n        // JSON numbers must be finite. Encode non-finite numbers as null.\n        return isFinite(value) ? wrap(token.num, String(value)) : wrap(token.lit, 'null');\n\n      case 'boolean':\n        return wrap(token.lit, String(value));\n\n      case 'object':\n        // If the type is 'object', we might be dealing with an object or an array or\n        // null.\n\n        // Due to a specification blunder in ECMAScript, typeof null is 'object',\n        // so watch out for that case.\n\n        if (!value) return wrap(token.lit, 'null');\n\n        var comments; // whitespace & comments\n        if (keepComments) comments = common.getComment(value);\n\n        var isArray = Object.prototype.toString.apply(value) === '[object Array]';\n\n        // Make an array to hold the partial results of stringifying this object value.\n        var mind = gap;\n        gap += indent;\n        var eolMind = eol + mind;\n        var eolGap = eol + gap;\n        var prefix = noIndent || bracesSameLine ? '' : eolMind;\n        var partial = [];\n        var setsep;\n        // condense helpers:\n        var cpartial = condense ? [] : null;\n        var saveQuoteStrings = quoteStrings, saveMultiline = multiline;\n        var iseparator = separator ? '' : token.com[0];\n        var cwrapLen = 0;\n\n        var i, length; // loop\n        var k, v, vs; // key, value\n        var c, ca;\n        var res, cres;\n\n        if (isArray) {\n          // The value is an array. Stringify every element. Use null as a placeholder\n          // for non-JSON values.\n\n          for (i = 0, length = value.length; i < length; i++) {\n            setsep = i < length -1;\n            if (comments) {\n              c = comments.a[i]||[];\n              ca = commentOnThisLine(c[1]);\n              partial.push(makeComment(c[0], \"\\n\") + eolGap);\n              if (cpartial && (c[0] || c[1] || ca)) cpartial = null;\n            }\n            else partial.push(eolGap);\n            wrapLen = 0;\n            v = value[i];\n            partial.push(str(v, comments ? ca : false, true) + (setsep ? separator : ''));\n            if (cpartial) {\n              // prepare the condensed version\n              switch (typeof v) {\n                case 'string':\n                  wrapLen = 0;\n                  quoteStrings = true; multiline = 0;\n                  cpartial.push(str(v, false, true) + (setsep ? token.com[0] : ''));\n                  quoteStrings = saveQuoteStrings; multiline = saveMultiline;\n                  break;\n                case 'object': if (v) { cpartial = null; break; } // falls through\n                default: cpartial.push(partial[partial.length - 1] + (setsep ? iseparator : '')); break;\n              }\n              if (setsep) wrapLen += token.com[0].length - token.com[2];\n              cwrapLen += wrapLen;\n            }\n            if (comments && c[1]) partial.push(makeComment(c[1], ca ? \" \" : \"\\n\", ca));\n          }\n\n          if (length === 0) {\n            // when empty\n            if (comments && comments.e) partial.push(makeComment(comments.e[0], \"\\n\") + eolMind);\n          }\n          else partial.push(eolMind);\n\n          // Join all of the elements together, separated with newline, and wrap them in\n          // brackets.\n\n          if (partial.length === 0) res = wrap(token.arr, '');\n          else {\n            res = prefix + wrap(token.arr, partial.join(''));\n            // try if the condensed version can fit (parent key name is not included)\n            if (cpartial) {\n              cres = cpartial.join(' ');\n              if (cres.length - cwrapLen <= condense) res = wrap(token.arr, cres);\n            }\n          }\n        } else {\n          // Otherwise, iterate through all of the keys in the object.\n          var commentKeys = comments ? comments.o.slice() : [];\n          var objectKeys = [];\n          for (k in value) {\n            if (Object.prototype.hasOwnProperty.call(value, k) && commentKeys.indexOf(k) < 0)\n              objectKeys.push(k);\n          }\n          if(sortProps) {\n            objectKeys.sort();\n          }\n          var keys = commentKeys.concat(objectKeys);\n\n          for (i = 0, length = keys.length; i < length; i++) {\n            setsep = i < length - 1;\n            k = keys[i];\n            if (comments) {\n              c = comments.c[k]||[];\n              ca = commentOnThisLine(c[1]);\n              partial.push(makeComment(c[0], \"\\n\") + eolGap);\n              if (cpartial && (c[0] || c[1] || ca)) cpartial = null;\n            }\n            else partial.push(eolGap);\n\n            wrapLen = 0;\n            v = value[k];\n            vs = str(v, comments && ca);\n            partial.push(quoteKey(k) + token.col[0] + (startsWithNL(vs) ? '' : ' ') + vs + (setsep ? separator : ''));\n            if (comments && c[1]) partial.push(makeComment(c[1], ca ? \" \" : \"\\n\", ca));\n            if (cpartial) {\n              // prepare the condensed version\n              switch (typeof v) {\n                case 'string':\n                  wrapLen = 0;\n                  quoteStrings = true; multiline = 0;\n                  vs = str(v, false);\n                  quoteStrings = saveQuoteStrings; multiline = saveMultiline;\n                  cpartial.push(quoteKey(k) + token.col[0] + ' ' + vs + (setsep ? token.com[0] : ''));\n                  break;\n                case 'object': if (v) { cpartial = null; break; } // falls through\n                default: cpartial.push(partial[partial.length - 1] + (setsep ? iseparator : '')); break;\n              }\n              wrapLen += token.col[0].length - token.col[2];\n              if (setsep) wrapLen += token.com[0].length - token.com[2];\n              cwrapLen += wrapLen;\n            }\n          }\n          if (length === 0) {\n            // when empty\n            if (comments && comments.e) partial.push(makeComment(comments.e[0], \"\\n\") + eolMind);\n          }\n          else partial.push(eolMind);\n\n          // Join all of the member texts together, separated with newlines\n          if (partial.length === 0) {\n            res = wrap(token.obj, '');\n          } else {\n            // and wrap them in braces\n            res = prefix + wrap(token.obj, partial.join(''));\n            // try if the condensed version can fit\n            if (cpartial) {\n              cres = cpartial.join(' ');\n              if (cres.length - cwrapLen <= condense) res = wrap(token.obj, cres);\n            }\n          }\n        }\n\n        gap = mind;\n        return res;\n    }\n  }\n\n\n  runDsf = dsf.loadDsf(dsfDef, 'stringify');\n\n  var res = \"\";\n  var comments = keepComments ? comments = (common.getComment(data) || {}).r : null;\n  if (comments && comments[0]) res = comments[0] + '\\n';\n\n  // get the result of stringifying the data.\n  res += str(data, null, true, true);\n\n  if (comments) res += comments[1]||\"\";\n\n  return res;\n};\n", "/* Hjson https://hjson.github.io */\n\"use strict\";\n\nvar common=require(\"./hjson-common\");\n\nfunction makeComment(b, a, x) {\n  var c;\n  if (b) c={ b: b };\n  if (a) (c=c||{}).a=a;\n  if (x) (c=c||{}).x=x;\n  return c;\n}\n\nfunction extractComments(value, root) {\n\n  if (value===null || typeof value!=='object') return;\n  var comments=common.getComment(value);\n  if (comments) common.removeComment(value);\n\n  var i, length; // loop\n  var any, res;\n  if (Object.prototype.toString.apply(value) === '[object Array]') {\n    res={ a: {} };\n    for (i=0, length=value.length; i<length; i++) {\n      if (saveComment(res.a, i, comments.a[i], extractComments(value[i])))\n        any=true;\n    }\n    if (!any && comments.e){\n      res.e=makeComment(comments.e[0], comments.e[1]);\n      any=true;\n    }\n  } else {\n    res={ s: {} };\n\n    // get key order (comments and current)\n    var keys, currentKeys=Object.keys(value);\n    if (comments && comments.o) {\n      keys=[];\n      comments.o.concat(currentKeys).forEach(function(key) {\n        if (Object.prototype.hasOwnProperty.call(value, key) && keys.indexOf(key)<0)\n          keys.push(key);\n      });\n    } else keys=currentKeys;\n    res.o=keys;\n\n    // extract comments\n    for (i=0, length=keys.length; i<length; i++) {\n      var key=keys[i];\n      if (saveComment(res.s, key, comments.c[key], extractComments(value[key])))\n        any=true;\n    }\n    if (!any && comments.e) {\n      res.e=makeComment(comments.e[0], comments.e[1]);\n      any=true;\n    }\n  }\n\n  if (root && comments && comments.r) {\n    res.r=makeComment(comments.r[0], comments.r[1]);\n  }\n\n  return any?res:undefined;\n}\n\nfunction mergeStr() {\n  var res=\"\";\n  [].forEach.call(arguments, function(c) {\n    if (c && c.trim()!==\"\") {\n      if (res) res+=\"; \";\n      res+=c.trim();\n    }\n  });\n  return res;\n}\n\nfunction mergeComments(comments, value) {\n  var dropped=[];\n  merge(comments, value, dropped, []);\n\n  // append dropped comments:\n  if (dropped.length>0) {\n    var text=rootComment(value, null, 1);\n    text+=\"\\n# Orphaned comments:\\n\";\n    dropped.forEach(function(c) {\n      text+=(\"# \"+c.path.join('/')+\": \"+mergeStr(c.b, c.a, c.e)).replace(\"\\n\", \"\\\\n \")+\"\\n\";\n    });\n    rootComment(value, text, 1);\n  }\n}\n\nfunction saveComment(res, key, item, col) {\n  var c=makeComment(item?item[0]:undefined, item?item[1]:undefined, col);\n  if (c) res[key]=c;\n  return c;\n}\n\nfunction droppedComment(path, c) {\n  var res=makeComment(c.b, c.a);\n  res.path=path;\n  return res;\n}\n\nfunction dropAll(comments, dropped, path) {\n\n  if (!comments) return;\n\n  var i, length; // loop\n\n  if (comments.a) {\n\n    for (i=0, length=comments.a.length; i<length; i++) {\n      var kpath=path.slice().concat([i]);\n      var c=comments.a[i];\n      if (c) {\n        dropped.push(droppedComment(kpath, c));\n        dropAll(c.x, dropped, kpath);\n      }\n    }\n  } else if (comments.o) {\n\n    comments.o.forEach(function(key) {\n      var kpath=path.slice().concat([key]);\n      var c=comments.s[key];\n      if (c) {\n        dropped.push(droppedComment(kpath, c));\n        dropAll(c.x, dropped, kpath);\n      }\n    });\n  }\n\n  if (comments.e)\n    dropped.push(droppedComment(path, comments.e));\n}\n\nfunction merge(comments, value, dropped, path) {\n\n  if (!comments) return;\n  if (value===null || typeof value!=='object') {\n    dropAll(comments, dropped, path);\n    return;\n  }\n\n  var i; // loop\n  var setComments=common.createComment(value);\n\n  if (path.length===0 && comments.r)\n    setComments.r=[comments.r.b, comments.r.a];\n\n  if (Object.prototype.toString.apply(value) === '[object Array]') {\n    setComments.a=[];\n    var a=comments.a||{}; // Treating Array like an Object, so using {} for speed\n    for (var key in a) {\n      if (a.hasOwnProperty(key)) {\n        i=parseInt(key);\n        var c=comments.a[key];\n        if (c) {\n          var kpath=path.slice().concat([i]);\n          if (i<value.length) {\n            setComments.a[i]=[c.b, c.a];\n            merge(c.x, value[i], dropped, kpath);\n          } else {\n            dropped.push(droppedComment(kpath, c));\n            dropAll(c.x, dropped, kpath);\n          }\n        }\n      }\n    }\n    if (i===0 && comments.e) setComments.e=[comments.e.b, comments.e.a];\n  } else {\n    setComments.c={};\n    setComments.o=[];\n    (comments.o||[]).forEach(function(key) {\n      var kpath=path.slice().concat([key]);\n      var c=comments.s[key];\n      if (Object.prototype.hasOwnProperty.call(value, key)) {\n        setComments.o.push(key);\n        if (c) {\n          setComments.c[key]=[c.b, c.a];\n          merge(c.x, value[key], dropped, kpath);\n        }\n      } else if (c) {\n        dropped.push(droppedComment(kpath, c));\n        dropAll(c.x, dropped, kpath);\n      }\n    });\n    if (comments.e) setComments.e=[comments.e.b, comments.e.a];\n  }\n}\n\nfunction rootComment(value, setText, header) {\n  var comment=common.createComment(value, common.getComment(value));\n  if (!comment.r) comment.r=[\"\", \"\"];\n  if (setText || setText===\"\") comment.r[header]=common.forceComment(setText);\n  return comment.r[header]||\"\";\n}\n\nmodule.exports={\n  extract: function(value) { return extractComments(value, true); },\n  merge: mergeComments,\n  header: function(value, setText) { return rootComment(value, setText, 0); },\n  footer: function(value, setText) { return rootComment(value, setText, 1); },\n};\n", "/*!\n * Hjson v3.2.1\n * https://hjson.github.io\n *\n * Copyright 2014-2017 Christian Zangl, MIT license\n * Details and documentation:\n * https://github.com/hjson/hjson-js\n *\n * This code is based on the the JSON version by Douglas Crockford:\n * https://github.com/douglascrockford/JSON-js (json_parse.js, json2.js)\n */\n\n/*\n\n  This file creates a Hjson object:\n\n\n    Hjson.parse(text, options)\n\n      options {\n        keepWsc     boolean, keep white space and comments. This is useful\n                    if you want to edit an hjson file and save it while\n                    preserving comments (default false)\n\n        dsf         array of DSF (see Hjson.dsf)\n\n        legacyRoot  boolean, support omitting root braces (default true)\n      }\n\n      This method parses Hjson text to produce an object or array.\n      It can throw a SyntaxError exception.\n\n\n    Hjson.stringify(value, options)\n\n      value         any JavaScript value, usually an object or array.\n\n      options {     all options are\n\n        keepWsc     boolean, keep white space. See parse.\n\n        condense    integer, will try to fit objects/arrays onto one line\n                    when the output is shorter than condense characters\n                    and the fragment contains no comments. Default 0 (off).\n\n        bracesSameLine\n                    boolean, makes braces appear on the same line as the key\n                    name. Default false.\n\n        quotes      string, controls how strings are displayed.\n                    setting separator implies \"strings\"\n                    \"min\"     - no quotes whenever possible (default)\n                    \"keys\"    - use quotes around keys\n                    \"strings\" - use quotes around string values\n                    \"all\"     - use quotes around keys and string values\n\n        multiline   string, controls how multiline strings are displayed.\n                    setting quotes implies \"off\"\n                    \"std\"     - strings containing \\n are shown in\n                                multiline format (default)\n                    \"no-tabs\" - like std but disallow tabs\n                    \"off\"     - show in JSON format\n\n        separator   boolean, output a comma separator between elements. Default false.\n\n        space       specifies the indentation of nested structures. If it is\n                    a number, it will specify the number of spaces to indent\n                    at each level. If it is a string (such as '\\t' or '  '),\n                    it contains the characters used to indent at each level.\n\n        eol         specifies the EOL sequence (default is set by\n                    Hjson.setEndOfLine())\n\n        colors      boolean, output ascii color codes\n\n        dsf         array of DSF (see Hjson.dsf)\n\n        emitRootBraces\n                    obsolete: will always emit braces\n\n        sortProps\n                    When serializing objects into hjson, order the keys based on\n                    their UTF-16 code units order\n      }\n\n      This method produces Hjson text from a JavaScript value.\n\n      Values that do not have JSON representations, such as undefined or\n      functions, will not be serialized. Such values in objects will be\n      dropped; in arrays they will be replaced with null.\n      stringify(undefined) returns undefined.\n\n\n    Hjson.endOfLine()\n    Hjson.setEndOfLine(eol)\n\n      Gets or sets the stringify EOL sequence ('\\n' or '\\r\\n').\n      When running with node.js this defaults to os.EOL.\n\n\n    Hjson.rt { parse, stringify }\n\n      This is a shortcut to roundtrip your comments when reading and updating\n      a config file. It is the same as specifying the keepWsc option for the\n      parse and stringify functions.\n\n\n    Hjson.version\n\n      The version of this library.\n\n\n    Hjson.dsf\n\n      Domain specific formats are extensions to the Hjson syntax (see\n      hjson.github.io). These formats will be parsed and made available to\n      the application in place of strings (e.g. enable math to allow\n      NaN values).\n\n      Hjson.dsf ontains standard DSFs that can be passed to parse\n      and stringify.\n\n\n    Hjson.dsf.math()\n\n      Enables support for Inf/inf, -Inf/-inf, Nan/naN and -0.\n      Will output as Inf, -Inf, NaN and -0.\n\n\n    Hjson.dsf.hex(options)\n\n      Parse hexadecimal numbers prefixed with 0x.\n      set options.out = true to stringify _all_ integers as hex.\n\n\n    Hjson.dsf.date(options)\n\n      support ISO dates\n\n\n  This is a reference implementation. You are free to copy, modify, or\n  redistribute.\n\n*/\n\n\"use strict\";\n\nvar common = require(\"./hjson-common\");\nvar version = require(\"./hjson-version\");\nvar parse = require(\"./hjson-parse\");\nvar stringify = require(\"./hjson-stringify\");\nvar comments = require(\"./hjson-comments\");\nvar dsf = require(\"./hjson-dsf\");\n\nmodule.exports={\n\n  parse: parse,\n  stringify: stringify,\n\n  endOfLine: function() { return common.EOL; },\n  setEndOfLine: function(eol) {\n    if (eol === '\\n' || eol === '\\r\\n') common.EOL = eol;\n  },\n\n  version: version,\n\n  // round trip shortcut\n  rt: {\n    parse: function(text, options) {\n      (options=options||{}).keepWsc=true;\n      return parse(text, options);\n    },\n    stringify: function(value, options) {\n      (options=options||{}).keepWsc=true;\n      return stringify(value, options);\n    },\n  },\n\n  comments: comments,\n\n  dsf: dsf.std,\n\n};\n"],
  "mappings": ";;;;;AAAA;AAAA;AAAA,WAAO,UAAU,OAAO,OAAO,IAAI,MAAM,CAAC,GAAG;AAAA,MAC3C,IAAI,GAAG,KAAK;AACV,YACE,QAAQ,gBACR,QAAQ,eACR,QAAQ,iBACR,QAAQ,UACR;AACA,kBAAQ,KAAK,kFAAkF,GAAG,qIAAqI;AAAA,QACzO;AAAA,MACF;AAAA,IACF,CAAC,CAAC;AAAA;AAAA;;;ACXF;AAAA;AAAA;AAGA,QAAI,KAAG;AAEP,aAAS,eAAe,MAAM,YAAY;AAIxC,UAAI,QAAQ,SAAS,IAAI,eAAe,GAAG,cAAc;AACzD,UAAI,KAAK;AACT,UAAI;AACJ,eAAS,OAAO;AACd,aAAK,KAAK,OAAO,EAAE;AACnB;AACA,eAAO;AAAA,MACT;AAEA,WAAK;AACL,UAAI,OAAO,KAAK;AACd,iBAAS;AACT,aAAK;AAAA,MACP;AACA,aAAO,MAAM,OAAO,MAAM,KAAK;AAC7B,YAAI,aAAa;AACf,cAAI,MAAM;AAAK;AAAA;AACV,0BAAc;AAAA,QACrB;AACA,kBAAU;AACV,aAAK;AAAA,MACP;AACA,UAAI;AAAa;AACjB,UAAI,OAAO,KAAK;AACd,kBAAU;AACV,eAAO,KAAK,KAAK,MAAM,OAAO,MAAM;AAClC,oBAAU;AAAA,MACd;AACA,UAAI,OAAO,OAAO,OAAO,KAAK;AAC5B,kBAAU;AACV,aAAK;AACL,YAAI,OAAO,OAAO,OAAO,KAAK;AAC5B,oBAAU;AACV,eAAK;AAAA,QACP;AACA,eAAO,MAAM,OAAO,MAAM,KAAK;AAC7B,oBAAU;AACV,eAAK;AAAA,QACP;AAAA,MACF;AAGA,aAAO,MAAM,MAAM;AAAK,aAAK;AAE7B,UAAI,YAAY;AAEd,YAAI,OAAO,OAAO,OAAO,OAAO,OAAO,OACrC,OAAO,OAAO,OAAO,QAAQ,KAAK,EAAE,MAAM,OAAO,KAAK,EAAE,MAAM;AAAM,eAAK;AAAA,MAC7E;AAEA,eAAS,CAAC;AACV,UAAI,MAAM,gBAAgB,CAAC,SAAS,MAAM;AAAG,eAAO;AAAA;AAC/C,eAAO;AAAA,IACd;AAEA,aAAS,cAAc,OAAO,SAAS;AACrC,UAAI,OAAO;AAAgB,eAAO,eAAe,OAAO,gBAAgB,EAAE,YAAY,OAAO,UAAU,KAAK,CAAC;AAC7G,aAAQ,MAAM,eAAe,WAAS,CAAC;AAAA,IACzC;AAEA,aAAS,cAAc,OAAO;AAC5B,aAAO,eAAe,OAAO,gBAAgB,EAAE,OAAO,OAAU,CAAC;AAAA,IACnE;AAEA,aAAS,WAAW,OAAO;AACzB,aAAO,MAAM;AAAA,IACf;AAEA,aAAS,aAAa,MAAM;AAC1B,UAAI,CAAC;AAAM,eAAO;AAClB,UAAI,IAAI,KAAK,MAAM,IAAI;AACvB,UAAI,KAAK,GAAG,GAAG;AACf,WAAK,IAAI,GAAG,IAAI,EAAE,QAAQ,KAAK;AAC7B,cAAM,EAAE,CAAC;AACT,cAAM,IAAI;AACV,aAAK,IAAI,GAAG,IAAI,KAAK,KAAK;AACxB,cAAI,IAAI,IAAI,CAAC;AACb,cAAI,MAAM;AAAK;AAAA,mBACN,MAAM,QAAQ,IAAI,IAAE,CAAC,MAAM,OAAO,IAAI,IAAE,CAAC,MAAM,MAAM;AAC5D,gBAAI,IAAI,IAAE,CAAC,MAAM;AAAK,kBAAI,EAAE;AAC5B;AAAA,UACF,WACS,IAAI,KAAK;AAChB,cAAE,CAAC,IAAI,OAAO;AACd;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,aAAO,EAAE,KAAK,IAAI;AAAA,IACpB;AAEA,WAAO,UAAU;AAAA,MACf,KAAK,GAAG,OAAO;AAAA,MACf;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA;AAAA;;;AC3GA;AAAA;AAAA,WAAO,UAAQ;AAAA;AAAA;;;ACAf;AAAA;AAAA;AAGA,aAAS,QAAQ,KAAK,MAAM;AAE1B,UAAI,OAAO,UAAU,SAAS,MAAM,GAAG,MAAM,kBAAkB;AAC7D,YAAI;AAAK,gBAAM,IAAI,MAAM,mCAAmC;AAAA;AACvD,iBAAO;AAAA,MACd,WAAW,IAAI,WAAW;AAAG,eAAO;AAEpC,UAAI,MAAM,CAAC;AACX,eAAS,WAAW,GAAG;AAAE,eAAO,CAAC,EAAE,SAAS,KAAK,CAAC,MAAM;AAAA,MAAqB;AAE7E,UAAI,QAAQ,SAAS,GAAG;AACtB,YAAI,CAAC,EAAE,QAAQ,CAAC,WAAW,EAAE,KAAK,KAAK,CAAC,WAAW,EAAE,SAAS;AAC5D,gBAAM,IAAI,MAAM,4CAA4C;AAC9D,YAAI,KAAK,WAAW;AAClB,cAAI;AACF,gBAAI,QAAQ,SAAS;AACnB,qBAAO,EAAE,MAAM,MAAM,MAAM,SAAS;AAAA,YACtC,WAAW,QAAQ,aAAa;AAC9B,kBAAI,MAAI,EAAE,UAAU,MAAM,MAAM,SAAS;AAEzC,kBAAI,QAAQ,WAAc,OAAO,QAAQ,YACvC,IAAI,WAAW,KACf,IAAI,CAAC,MAAM,OACX,CAAC,EAAE,KAAK,KAAK,KAAK,SAAS,GAAG;AAAE,uBAAO,iBAAiB,CAAC;AAAA,cAAG,CAAC;AAC7D,sBAAM,IAAI,MAAM,gGAAgG,GAAG;AACrH,qBAAO;AAAA,YACT;AAAO,oBAAM,IAAI,MAAM,cAAc;AAAA,UACvC,SAAS,GAAG;AACV,kBAAM,IAAI,MAAM,SAAO,EAAE,OAAK,cAAY,EAAE,OAAO;AAAA,UACrD;AAAA,QACF,CAAC;AAAA,MACH,CAAC;AAED,aAAO,OAAO,KAAK,MAAM,GAAG;AAAA,IAC9B;AAEA,aAAS,OAAO,KAAK,OAAO;AAC1B,UAAI,KAAK;AACP,iBAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACnC,cAAI,MAAM,IAAI,CAAC,EAAE,KAAK;AACtB,cAAI,QAAQ;AAAW,mBAAO;AAAA,QAChC;AAAA,MACF;AAAA,IACF;AAEA,aAAS,SAAkB;AAAA,IAC3B;AAEA,aAAS,iBAAiB,GAAG;AAC3B,aAAO,MAAM,OAAO,MAAM,OAAO,MAAM,OAAO,MAAM,OAAO,MAAM;AAAA,IACnE;AAGA,aAAS,OAAc;AACrB,aAAO;AAAA,QACL,MAAM;AAAA,QACN,OAAO,SAAU,OAAO;AACtB,kBAAQ,OAAO;AAAA,YACb,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AAAO,qBAAO;AAAA,YACnB,KAAK;AAAA,YACL,KAAK;AAAQ,qBAAO;AAAA,YACpB,KAAK;AAAA,YACL,KAAK;AAAO,qBAAO;AAAA,UACrB;AAAA,QACF;AAAA,QACA,WAAW,SAAU,OAAO;AAC1B,cAAI,OAAO,UAAU;AAAU;AAC/B,cAAI,IAAI,UAAU;AAAW,mBAAO;AACpC,cAAI,UAAU;AAAU,mBAAO;AAC/B,cAAI,UAAU;AAAW,mBAAO;AAChC,cAAI,MAAM,KAAK;AAAG,mBAAO;AAAA,QAC3B;AAAA,MACF;AAAA,IACF;AACA,SAAK,cAAY;AAEjB,aAAS,IAAI,KAAK;AAChB,UAAI,MAAI,OAAO,IAAI;AACnB,aAAO;AAAA,QACL,MAAM;AAAA,QACN,OAAO,SAAU,OAAO;AACtB,cAAI,mBAAmB,KAAK,KAAK;AAC/B,mBAAO,SAAS,OAAO,EAAE;AAAA,QAC7B;AAAA,QACA,WAAW,SAAU,OAAO;AAC1B,cAAI,OAAO,OAAO,UAAU,KAAK;AAC/B,mBAAO,OAAK,MAAM,SAAS,EAAE;AAAA,QACjC;AAAA,MACF;AAAA,IACF;AACA,QAAI,cAAY;AAEhB,aAAS,OAAc;AACrB,aAAO;AAAA,QACL,MAAM;AAAA,QACN,OAAO,SAAU,OAAO;AACtB,cAAI,sBAAsB,KAAK,KAAK,KAClC,uEAAuE,KAAK,KAAK,GAAG;AACpF,gBAAI,KAAK,KAAK,MAAM,KAAK;AACzB,gBAAI,CAAC,MAAM,EAAE;AAAG,qBAAO,IAAI,KAAK,EAAE;AAAA,UACpC;AAAA,QACF;AAAA,QACA,WAAW,SAAU,OAAO;AAC1B,cAAI,OAAO,UAAU,SAAS,KAAK,KAAK,MAAM,iBAAiB;AAC7D,gBAAI,KAAK,MAAM,YAAY;AAC3B,gBAAI,GAAG,QAAQ,kBAAkB,GAAG,SAAS,EAAE,MAAM;AAAI,qBAAO,GAAG,OAAO,GAAG,EAAE;AAAA;AAC1E,qBAAO;AAAA,UACd;AAAA,QACF;AAAA,MACF;AAAA,IACF;AACA,SAAK,cAAY;AAEjB,WAAO,UAAU;AAAA,MACf;AAAA,MACA,KAAK;AAAA,QACH;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA;AAAA;;;AC9HA;AAAA;AAAA;AAGA,WAAO,UAAU,SAAS,QAAQ,KAAK;AAErC,UAAI,SAAS;AACb,UAAI,MAAM;AAEV,UAAI;AACJ,UAAI;AACJ,UAAI;AACJ,UAAI,UAAU;AAAA,QACZ,KAAK;AAAA,QACL,KAAK;AAAA,QACL,MAAM;AAAA,QACN,KAAK;AAAA,QACL,GAAI;AAAA,QACJ,GAAI;AAAA,QACJ,GAAI;AAAA,QACJ,GAAI;AAAA,QACJ,GAAI;AAAA,MACN;AAEA,UAAI;AACJ,UAAI;AAEJ,eAAS,UAAU;AACjB,aAAK;AACL,aAAK;AAAA,MACP;AAEA,eAAS,iBAAiB,GAAG;AAC3B,eAAO,MAAM,OAAO,MAAM,OAAO,MAAM,OAAO,MAAM,OAAO,MAAM,OAAO,MAAM;AAAA,MAChF;AAGA,eAAS,MAAM,GAAG;AAChB,YAAI,GAAG,MAAI,GAAG,OAAK;AACnB,aAAK,IAAI,KAAG,GAAG,IAAI,KAAK,KAAK,CAAC,MAAM,MAAM,KAAK,OAAO;AAAA,QAAC;AACvD,eAAO,IAAI,GAAG;AAAK,cAAI,KAAK,CAAC,MAAM;AAAM;AACzC,cAAM,IAAI,MAAM,IAAI,cAAc,OAAO,MAAM,MAAM,SAAS,KAAK,OAAO,KAAG,KAAK,EAAE,IAAI,MAAM;AAAA,MAChG;AAEA,eAAS,OAAO;AAEd,aAAK,KAAK,OAAO,EAAE;AACnB;AACA,eAAO;AAAA,MACT;AAEA,eAAS,KAAK,MAAM;AAElB,eAAO,KAAK,OAAO,KAAK,IAAI;AAAA,MAC9B;AAEA,eAAS,OAAO,SAAS;AAGvB,YAAIA,UAAS;AAGb,YAAI,SAAS;AACb,eAAO,KAAK,GAAG;AACb,cAAI,OAAO,QAAQ;AACjB,iBAAK;AACL,gBAAI,WAAW,WAAW,OAAO,OAAO,OAAOA,QAAO,WAAW,GAAG;AAElE,mBAAK;AACL,qBAAO,SAAS;AAAA,YAClB;AAAO,qBAAOA;AAAA,UAChB;AACA,cAAI,OAAO,MAAM;AACf,iBAAK;AACL,gBAAI,OAAO,KAAK;AACd,kBAAI,QAAQ;AACZ,uBAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,qBAAK;AACL,oBAAI,IAAI,GAAG,WAAW,CAAC,GAAG;AAC1B,oBAAI,MAAM,OAAO,MAAM;AAAK,wBAAM,IAAI;AAAA,yBAC7B,MAAM,OAAO,MAAM;AAAK,wBAAM,IAAI,KAAK;AAAA,yBACvC,MAAM,OAAO,MAAM;AAAK,wBAAM,IAAI,KAAK;AAAA;AAC3C,wBAAM,kBAAkB,EAAE;AAC/B,wBAAQ,QAAQ,KAAK;AAAA,cACvB;AACA,cAAAA,WAAU,OAAO,aAAa,KAAK;AAAA,YACrC,WAAW,OAAO,QAAQ,EAAE,MAAM,UAAU;AAC1C,cAAAA,WAAU,QAAQ,EAAE;AAAA,YACtB;AAAO;AAAA,UACT,WAAW,OAAO,QAAQ,OAAO,MAAM;AACrC,kBAAM,+BAA+B;AAAA,UACvC,OAAO;AACL,YAAAA,WAAU;AAAA,UACZ;AAAA,QACF;AACA,cAAM,YAAY;AAAA,MACpB;AAEA,eAAS,WAAW;AAElB,YAAIA,UAAS,IAAI,SAAS;AAG1B,YAAI,SAAS;AACb,mBAAS;AACP,cAAI,IAAE,KAAK,CAAC,SAAO,CAAC;AACpB,cAAI,CAAC,KAAK,MAAM;AAAM;AACtB;AAAA,QACF;AAEA,iBAAS,aAAa;AACpB,cAAI,OAAO;AACX,iBAAO,MAAM,MAAM,OAAO,OAAO,QAAQ,SAAS;AAAG,iBAAK;AAAA,QAC5D;AAGA,eAAO,MAAM,MAAM,OAAO,OAAO;AAAM,eAAK;AAC5C,YAAI,OAAO,MAAM;AAAE,eAAK;AAAG,qBAAW;AAAA,QAAG;AAGzC,mBAAS;AACP,cAAI,CAAC,IAAI;AACP,kBAAM,sBAAsB;AAAA,UAC9B,WAAW,OAAO,KAAM;AACtB;AACA,iBAAK;AACL,gBAAI,WAAW,GAAG;AAChB,kBAAIA,QAAO,MAAM,EAAE,MAAM;AAAM,gBAAAA,UAAOA,QAAO,MAAM,GAAG,EAAE;AACxD,qBAAOA;AAAA,YACT;AAAO;AAAA,UACT,OAAO;AACL,mBAAO,SAAS,GAAG;AACjB,cAAAA,WAAU;AACV;AAAA,YACF;AAAA,UACF;AACA,cAAI,OAAO,MAAM;AACf,YAAAA,WAAU;AACV,iBAAK;AACL,uBAAW;AAAA,UACb,OAAO;AACL,gBAAI,OAAO;AAAM,cAAAA,WAAU;AAC3B,iBAAK;AAAA,UACP;AAAA,QACF;AAAA,MACF;AAEA,eAAS,UAAU;AAIjB,YAAI,OAAO,OAAO,OAAO;AAAK,iBAAO,OAAO,KAAK;AAEjD,YAAI,OAAO,IAAI,QAAQ,IAAI,QAAQ;AACnC,mBAAS;AACP,cAAI,OAAO,KAAK;AACd,gBAAI,CAAC;AAAM,oBAAM,8DAA8D;AAAA,qBACtE,SAAQ,KAAK,UAAU,KAAK,QAAQ;AAAE,mBAAK,QAAQ;AAAO,oBAAM,2DAA2D;AAAA,YAAG;AACvI,mBAAO;AAAA,UACT,WAAW,MAAM,KAAK;AACpB,gBAAI,CAAC;AAAI,oBAAM,4DAA4D;AAAA,qBAClE,QAAQ;AAAG,sBAAQ,KAAK;AAAA,UACnC,WAAW,iBAAiB,EAAE,GAAG;AAC/B,kBAAM,YAAY,KAAK,iHAAiH;AAAA,UAC1I,OAAO;AACL,oBAAQ;AAAA,UACV;AACA,eAAK;AAAA,QACP;AAAA,MACF;AAEA,eAAS,QAAQ;AACf,eAAO,IAAI;AAET,iBAAO,MAAM,MAAM;AAAK,iBAAK;AAE7B,cAAI,OAAO,OAAO,OAAO,OAAO,KAAK,CAAC,MAAM,KAAK;AAC/C,mBAAO,MAAM,OAAO;AAAM,mBAAK;AAAA,UACjC,WAAW,OAAO,OAAO,KAAK,CAAC,MAAM,KAAK;AACxC,iBAAK;AAAG,iBAAK;AACb,mBAAO,MAAM,EAAE,OAAO,OAAO,KAAK,CAAC,MAAM;AAAM,mBAAK;AACpD,gBAAI,IAAI;AAAE,mBAAK;AAAG,mBAAK;AAAA,YAAG;AAAA,UAC5B;AAAO;AAAA,QACT;AAAA,MACF;AAEA,eAAS,QAAQ;AAGf,YAAIC,SAAQ;AACZ,YAAI,iBAAiB,EAAE;AACrB,gBAAM,mCAAmC,KAAK,yDAAyD;AAEzG,mBAAQ;AACN,eAAK;AAEL,cAAI,QAAQ,OAAO,QAAQ,OAAO,QAAQ,OAAO;AACjD,cAAI,SACF,OAAO,OAAO,OAAO,OAAO,OAAO,OACnC,OAAO,OACP,OAAO,QAAQ,KAAK,CAAC,MAAM,OAAO,KAAK,CAAC,MAAM,MAC5C;AAIF,gBAAI,MAAMA,OAAM,CAAC;AACjB,oBAAQ,KAAK;AAAA,cACX,KAAK;AAAK,oBAAIA,OAAM,KAAK,MAAM;AAAS,yBAAO;AAAO;AAAA,cACtD,KAAK;AAAK,oBAAIA,OAAM,KAAK,MAAM;AAAQ,yBAAO;AAAM;AAAA,cACpD,KAAK;AAAK,oBAAIA,OAAM,KAAK,MAAM;AAAQ,yBAAO;AAAM;AAAA,cACpD;AACE,oBAAI,QAAQ,OAAO,OAAO,OAAO,OAAO,KAAK;AAC3C,sBAAI,IAAI,OAAO,eAAeA,MAAK;AACnC,sBAAI,MAAM;AAAW,2BAAO;AAAA,gBAC9B;AAAA,YACJ;AACA,gBAAI,OAAO;AAET,cAAAA,SAAQA,OAAM,KAAK;AACnB,kBAAI,WAAW,OAAOA,MAAK;AAC3B,qBAAO,aAAa,SAAY,WAAWA;AAAA,YAC7C;AAAA,UACF;AACA,UAAAA,UAAS;AAAA,QACX;AAAA,MACF;AAEA,eAAS,WAAW,KAAK,OAAO;AAC9B,YAAI;AACJ;AAGA,aAAK,IAAI,KAAK,GAAG,IAAI,OAAO,KAAK,CAAC,KAAK,OAAO,KAAK,CAAC,MAAM,MAAM;AAAI;AACpE,YAAI,KAAK,CAAC,MAAM;AAAM;AACtB,YAAI,KAAK,CAAC,MAAM;AAAM;AACtB,YAAI,MAAM,KAAK,OAAO,KAAK,IAAE,MAAI,CAAC;AAElC,aAAK,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AAC/B,cAAI,IAAI,CAAC,IAAI,KAAK;AAChB,gBAAI,IAAI,IAAI,QAAQ,IAAI;AACxB,gBAAI,KAAK,GAAG;AACV,kBAAI,IAAI,CAAC,IAAI,OAAO,GAAG,CAAC,GAAG,IAAI,OAAO,IAAE,CAAC,CAAC;AAC1C,kBAAI,SAAS,EAAE,CAAC,EAAE,KAAK,EAAE,WAAW;AAAG,kBAAE,MAAM;AAC/C,qBAAO;AAAA,YACT;AAAO,qBAAO,CAAC,GAAG;AAAA,UACpB;AAAA,QACF;AACA,eAAO,CAAC;AAAA,MACV;AAEA,eAAS,iBAAiBA,QAAO;AAC/B,iBAAS,OAAOA,QAAOC,KAAI;AACzB,cAAI,GAAG,GAAG,QAAQ;AAClB,kBAAQ,OAAOD,QAAO;AAAA,YACpB,KAAK;AACH,kBAAIA,OAAM,QAAQC,GAAE,KAAK;AAAG,sBAAMD;AAClC;AAAA,YACF,KAAK;AACH,kBAAI,OAAO,UAAU,SAAS,MAAMA,MAAK,MAAM,kBAAkB;AAC/D,qBAAK,IAAI,GAAG,SAASA,OAAM,QAAQ,IAAI,QAAQ,KAAK;AAClD,wBAAI,OAAOA,OAAM,CAAC,GAAGC,GAAE,KAAK;AAAA,gBAC9B;AAAA,cACF,OAAO;AACL,qBAAK,KAAKD,QAAO;AACf,sBAAI,CAAC,OAAO,UAAU,eAAe,KAAKA,QAAO,CAAC;AAAG;AACrD,wBAAI,OAAOA,OAAM,CAAC,GAAGC,GAAE,KAAK;AAAA,gBAC9B;AAAA,cACF;AAAA,UACJ;AACA,iBAAO;AAAA,QACT;AAEA,iBAAS,OAAOA,KAAI;AAClB,cAAI,cAAY,OAAOD,QAAOC,GAAE;AAChC,cAAI,aAAa;AACf,mBAAO,YAAUA,MAAG,2DACX,cAAY;AAAA,UAEvB;AAAO,mBAAO;AAAA,QAChB;AAEA,eAAO,OAAO,GAAG,KAAK,OAAO,GAAG;AAAA,MAClC;AAEA,eAAS,QAAQ;AAIf,YAAIC,SAAQ,CAAC;AACb,YAAI,UAAU,KAAK;AACnB,YAAI;AACF,cAAI;AAAc,uBAAW,OAAO,cAAcA,QAAO,EAAE,GAAG,CAAC,EAAE,CAAC;AAElE,eAAK;AACL,gBAAM;AACN,gBAAM;AACN,cAAI;AAAU,0BAAc,WAAW,KAAK,IAAI,EAAE,KAAK,IAAI;AAC3D,cAAI,OAAO,KAAK;AACd,iBAAK;AACL,gBAAI;AAAU,uBAAS,IAAI,CAAC,WAAW;AACvC,mBAAOA;AAAA,UACT;AAEA,iBAAO,IAAI;AACT,YAAAA,OAAM,KAAK,MAAM,CAAC;AAClB,kBAAM;AACN,kBAAM;AAGN,gBAAI,OAAO,KAAK;AAAE,mBAAK;AAAG,oBAAM;AAAI,oBAAM;AAAA,YAAG;AAC7C,gBAAI,UAAU;AACZ,kBAAI,IAAI,WAAW,GAAG;AACtB,uBAAS,EAAE,KAAK,CAAC,eAAa,IAAI,EAAE,CAAC,KAAG,EAAE,CAAC;AAC3C,4BAAc,EAAE,CAAC;AAAA,YACnB;AACA,gBAAI,OAAO,KAAK;AACd,mBAAK;AACL,kBAAI;AAAU,yBAAS,EAAE,SAAS,EAAE,SAAO,CAAC,EAAE,CAAC,KAAK,eAAa;AACjE,qBAAOA;AAAA,YACT;AACA,kBAAM;AAAA,UACR;AAEA,gBAAM,mDAAmD;AAAA,QAC3D,SAAS,GAAG;AACV,YAAE,OAAK,EAAE,QAAM,iBAAiBA,MAAK;AACrC,gBAAM;AAAA,QACR;AAAA,MACF;AAEA,eAAS,OAAO,eAAe;AAG7B,YAAI,MAAM,IAAIC,UAAS,CAAC;AACxB,YAAI,UAAU,KAAK;AAEnB,YAAI;AACF,cAAI;AAAc,uBAAW,OAAO,cAAcA,SAAQ,EAAE,GAAG,CAAC,GAAG,GAAG,CAAC,EAAG,CAAC;AAE3E,cAAI,CAAC,eAAe;AAElB,iBAAK;AACL,kBAAM;AAAA,UACR;AAAO,kBAAM;AAEb,gBAAM;AACN,cAAI;AAAU,0BAAc,WAAW,KAAK,IAAI,EAAE,KAAK,IAAI;AAC3D,cAAI,OAAO,OAAO,CAAC,eAAe;AAChC,gBAAI;AAAU,uBAAS,IAAI,CAAC,WAAW;AACvC,iBAAK;AACL,mBAAOA;AAAA,UACT;AACA,iBAAO,IAAI;AACT,kBAAM,QAAQ;AACd,kBAAM;AACN,gBAAI,OAAO;AAAK,oBAAM,8BAA8B,KAAK,GAAG;AAC5D,iBAAK;AAEL,YAAAA,QAAO,GAAG,IAAI,MAAM;AACpB,kBAAM;AACN,kBAAM;AAGN,gBAAI,OAAO,KAAK;AAAE,mBAAK;AAAG,oBAAM;AAAI,oBAAM;AAAA,YAAG;AAC7C,gBAAI,UAAU;AACZ,kBAAI,IAAI,WAAW,GAAG;AACtB,uBAAS,EAAE,GAAG,IAAI,CAAC,eAAa,IAAI,EAAE,CAAC,KAAG,EAAE;AAC5C,4BAAc,EAAE,CAAC;AACjB,uBAAS,EAAE,KAAK,GAAG;AAAA,YACrB;AACA,gBAAI,OAAO,OAAO,CAAC,eAAe;AAChC,mBAAK;AACL,kBAAI;AAAU,yBAAS,EAAE,GAAG,EAAE,CAAC,KAAK,eAAa;AACjD,qBAAOA;AAAA,YACT;AACA,kBAAM;AAAA,UACR;AAEA,cAAI;AAAe,mBAAOA;AAAA;AACrB,kBAAM,oDAAoD;AAAA,QACjE,SAAS,GAAG;AACV,YAAE,OAAK,EAAE,QAAM,iBAAiBA,OAAM;AACtC,gBAAM;AAAA,QACR;AAAA,MACF;AAEA,eAAS,QAAQ;AAGf,cAAM;AACN,gBAAQ,IAAI;AAAA,UACV,KAAK;AAAK,mBAAO,OAAO;AAAA,UACxB,KAAK;AAAK,mBAAO,MAAM;AAAA,UACvB,KAAK;AAAA,UACL,KAAK;AAAK,mBAAO,OAAO,IAAI;AAAA,UAC5B;AAAS,mBAAO,MAAM;AAAA,QACxB;AAAA,MACF;AAEA,eAAS,cAAc,GAAG,GAAG;AAC3B,YAAI,MAAM;AACV,cAAM;AACN,YAAI;AAAI,gBAAM,yCAAyC;AACvD,YAAI,cAAc;AAChB,cAAI,IAAI,EAAE,KAAK,IAAI,GAAG,IAAI,WAAW,GAAG,EAAE,KAAK,IAAI;AACnD,cAAI,KAAK,GAAG;AACV,gBAAI,WAAW,OAAO,cAAc,GAAG,OAAO,WAAW,CAAC,CAAC;AAC3D,qBAAS,IAAI,CAAC,GAAG,CAAC;AAAA,UACpB;AAAA,QACF;AACA,eAAO;AAAA,MACT;AAEA,eAAS,YAAY;AACnB,cAAM;AACN,YAAI,IAAI,eAAe,WAAW,CAAC,IAAI;AACvC,gBAAQ,IAAI;AAAA,UACV,KAAK;AAAK,mBAAO,cAAc,OAAO,GAAG,CAAC;AAAA,UAC1C,KAAK;AAAK,mBAAO,cAAc,MAAM,GAAG,CAAC;AAAA,UACzC;AAAS,mBAAO,cAAc,MAAM,GAAG,CAAC;AAAA,QAC1C;AAAA,MACF;AAEA,eAAS,kBAAkB;AAEzB,cAAM;AACN,YAAI,IAAI,eAAe,WAAW,CAAC,IAAI;AACvC,gBAAQ,IAAI;AAAA,UACV,KAAK;AAAK,mBAAO,cAAc,OAAO,GAAG,CAAC;AAAA,UAC1C,KAAK;AAAK,mBAAO,cAAc,MAAM,GAAG,CAAC;AAAA,QAC3C;AAEA,YAAI;AAEF,iBAAO,cAAc,OAAO,IAAI,GAAG,CAAC;AAAA,QACtC,SAAS,GAAG;AAEV,kBAAQ;AACR,cAAI;AAAE,mBAAO,cAAc,MAAM,GAAG,CAAC;AAAA,UAAG,SACjC,IAAI;AAAE,kBAAM;AAAA,UAAG;AAAA,QACxB;AAAA,MACF;AAEA,UAAI,OAAO,WAAS;AAAU,cAAM,IAAI,MAAM,wBAAwB;AACtE,UAAI,SAAS;AACb,UAAI,aAAa;AACjB,UAAI,OAAO,OAAO,QAAQ,UAAU;AAClC,uBAAe,IAAI;AACnB,iBAAS,IAAI;AACb,qBAAa,IAAI,eAAe;AAAA,MAClC;AACA,eAAS,IAAI,QAAQ,QAAQ,OAAO;AACpC,aAAO;AACP,cAAQ;AACR,aAAO,aAAa,gBAAgB,IAAI,UAAU;AAAA,IACpD;AAAA;AAAA;;;ACtcA;AAAA;AAAA;AAGA,WAAO,UAAU,SAAS,MAAM,KAAK;AAEnC,UAAI,SAAS;AACb,UAAI,MAAM;AAEV,UAAI,aAAa;AAAA,QACf,KAAM,CAAE,KAAK,GAAI;AAAA,QACjB,KAAM,CAAE,KAAK,GAAI;AAAA,QACjB,KAAM,CAAE,IAAK,EAAG;AAAA,QAChB,MAAM,CAAE,KAAK,GAAI;AAAA,QACjB,KAAM,CAAE,KAAK,EAAG;AAAA,QAChB,KAAM,CAAE,KAAK,EAAG;AAAA,QAChB,KAAM,CAAE,IAAI,EAAG;AAAA,QACf,MAAM,CAAE,KAAK,GAAI;AAAA,QACjB,MAAM,CAAE,OAAO,KAAM;AAAA,QACrB,KAAM,CAAE,IAAI,EAAG;AAAA,QACf,KAAM,CAAE,IAAI,EAAG;AAAA,QACf,KAAM,CAAE,IAAI,EAAG;AAAA,QACf,KAAM,CAAE,MAAM,EAAG;AAAA,QACjB,KAAM,CAAE,OAAO,EAAG;AAAA,QAClB,KAAM,CAAE,IAAI,EAAG;AAAA,MACjB;AAGA,UAAI,MAAM,OAAO;AACjB,UAAI,SAAS;AACb,UAAI,eAAe;AACnB,UAAI,iBAAiB;AACrB,UAAI,YAAY;AAChB,UAAI,eAAe;AACnB,UAAI,WAAW;AACf,UAAI,YAAY;AAChB,UAAI,YAAY;AAChB,UAAI,SAAS;AACb,UAAI,YAAY;AAChB,UAAI,QAAQ;AAEZ,UAAI,OAAO,OAAO,QAAQ,UAAU;AAClC,YAAI,SAAS,IAAI,WAAW,WAAW,YAAY,IAAI;AAEvD,YAAI,IAAI,QAAQ,QAAQ,IAAI,QAAQ;AAAQ,gBAAM,IAAI;AACtD,uBAAe,IAAI;AACnB,mBAAW,IAAI,YAAY;AAC3B,yBAAiB,IAAI;AACrB,oBAAY,IAAI,WAAW,SAAS,IAAI,WAAW;AACnD,uBAAe,IAAI,WAAW,SAAS,IAAI,WAAW,aAAa,IAAI,cAAc;AACrF,YAAI,gBAAgB,IAAI,aAAa;AAAO,sBAAY;AAAA;AACnD,sBAAY,IAAI,aAAa,YAAY,IAAI;AAClD,oBAAY,IAAI,cAAc,OAAO,MAAM,IAAI,CAAC,IAAI;AACpD,iBAAS,IAAI;AACb,oBAAY,IAAI;AAKhB,YAAI,OAAO,IAAI,UAAU,UAAU;AACjC,mBAAS,IAAI,MAAM,IAAI,QAAQ,CAAC,EAAE,KAAK,GAAG;AAAA,QAC5C,WAAW,OAAO,IAAI,UAAU,UAAU;AACxC,mBAAS,IAAI;AAAA,QACf;AAEA,YAAI,IAAI,WAAW,MAAM;AACvB,kBAAQ;AAAA,YACN,KAAM,CAAE,oBAAoB,kBAAmB;AAAA,YAC/C,KAAM,CAAE,oBAAoB,kBAAmB;AAAA,YAC/C,KAAM,CAAE,YAAa,SAAU;AAAA,YAC/B,MAAM,CAAE,aAAa,UAAW;AAAA,YAChC,KAAM,CAAE,oBAAoB,EAAG;AAAA,YAC/B,KAAM,CAAE,oBAAoB,EAAG;AAAA,YAC/B,KAAM,CAAE,cAAc,SAAU;AAAA,YAChC,MAAM,CAAE,eAAe,UAAW;AAAA,YAClC,MAAM,CAAE,iBAAiB,YAAa;AAAA,YACtC,KAAM,CAAE,cAAc,SAAU;AAAA,YAChC,KAAM,CAAE,YAAY,SAAU;AAAA,YAC9B,KAAM,CAAE,YAAY,SAAU;AAAA,YAC9B,KAAM,CAAE,cAAc,SAAU;AAAA,YAChC,KAAM,CAAE,eAAe,SAAU;AAAA,YACjC,KAAM,CAAE,YAAY,SAAU;AAAA,UAChC;AAAA,QACF;AAEA,YAAI,GAAG,QAAM,OAAO,KAAK,UAAU;AACnC,aAAK,IAAI,MAAM,SAAS,GAAG,KAAK,GAAG,KAAK;AACtC,cAAI,IAAI,MAAM,CAAC;AACf,gBAAM,CAAC,EAAE,KAAK,WAAW,CAAC,EAAE,CAAC,EAAE,QAAQ,WAAW,CAAC,EAAE,CAAC,EAAE,MAAM;AAAA,QAChE;AAAA,MACF;AAGA,UAAI;AAEJ,UAAI,cAAY;AAEhB,UAAI,cAAc,IAAI,OAAO,iBAAoB,cAAY,KAAK,GAAG;AAErE,UAAI,cAAc,IAAI,OAAO,uEAA2E,cAAY,KAAK,GAAG;AAE5H,UAAI,gBAAgB,IAAI,OAAO,uBAA0B,cAAc,IAAI,MAAS,QAAQ,YAAoB,cAAY,KAAK,GAAG;AAEpI,UAAI,oBAAoB,IAAI,OAAO,mDAAmD;AACtF,UAAI,OAAO;AAAA;AAAA,QAET,MAAM;AAAA,QACN,KAAM;AAAA,QACN,MAAM;AAAA,QACN,MAAM;AAAA,QACN,MAAM;AAAA,QACN,KAAM;AAAA,QACN,MAAM;AAAA,MACR;AACA,UAAI,kBAAkB;AACtB,UAAI,MAAM;AAEV,UAAI,UAAU;AAEd,eAAS,KAAK,IAAI,GAAG;AACnB,mBAAW,GAAG,CAAC,EAAE,SAAS,GAAG,CAAC,EAAE,SAAS,GAAG,CAAC,IAAI,GAAG,CAAC;AACrD,eAAO,GAAG,CAAC,IAAI,IAAI,GAAG,CAAC;AAAA,MACzB;AAEA,eAAS,aAAa,QAAQ;AAC5B,eAAO,OAAO,QAAQ,aAAa,SAAU,GAAG;AAC9C,cAAI,IAAI,KAAK,CAAC;AACd,cAAI,OAAO,MAAM;AAAU,mBAAO,KAAK,MAAM,KAAK,CAAC;AAAA;AAC9C,mBAAO,KAAK,MAAM,MAAM,SAAS,EAAE,WAAW,CAAC,EAAE,SAAS,EAAE,GAAG,MAAM,EAAE,CAAC;AAAA,QAC/E,CAAC;AAAA,MACH;AAEA,eAAS,MAAM,QAAQC,MAAK,YAAY,cAAc;AACpD,YAAI,CAAC;AAAQ,iBAAO,KAAK,MAAM,MAAM,EAAE;AAEvC,oBAAY,YAAY;AACxB,0BAAkB,YAAY;AAK9B,YAAI,gBAAgB,cAClB,YAAY,KAAK,MAAM,KACvB,OAAO,eAAe,QAAQ,IAAI,MAAM,UACxC,kBAAkB,KAAK,MAAM,GAAG;AAQhC,sBAAY,YAAY;AACxB,wBAAc,YAAY;AAC1B,cAAI,CAAC,YAAY,KAAK,MAAM;AAAG,mBAAO,KAAK,MAAM,MAAM,MAAM;AAAA,mBACpD,CAAC,cAAc,KAAK,MAAM,KAAK,CAAC,gBAAgB;AAAW,mBAAO,SAAS,QAAQA,IAAG;AAAA;AAC1F,mBAAO,KAAK,MAAM,MAAM,aAAa,MAAM,CAAC;AAAA,QACnD,OAAO;AAEL,iBAAO,KAAK,MAAM,KAAK,MAAM;AAAA,QAC/B;AAAA,MACF;AAEA,eAAS,SAAS,QAAQA,MAAK;AAG7B,YAAIC,IAAG,IAAI,OAAO,QAAQ,OAAO,EAAE,EAAE,MAAM,IAAI;AAC/C,QAAAD,QAAO;AAEP,YAAI,EAAE,WAAW,GAAG;AAIlB,iBAAO,KAAK,MAAM,MAAM,EAAE,CAAC,CAAC;AAAA,QAC9B,OAAO;AACL,cAAIE,OAAM,MAAMF,OAAM,MAAM,KAAK,CAAC;AAClC,eAAKC,KAAI,GAAGA,KAAI,EAAE,QAAQA,MAAK;AAC7B,YAAAC,QAAO;AACP,gBAAI,EAAED,EAAC;AAAG,cAAAC,QAAOF,OAAM,EAAEC,EAAC;AAAA,UAC5B;AACA,iBAAOC,OAAM,MAAMF,OAAM,MAAM,KAAK,CAAC;AAAA,QACvC;AAAA,MACF;AAEA,eAAS,SAAS,MAAM;AACtB,YAAI,CAAC;AAAM,iBAAO;AAIlB,YAAI,aAAa,gBAAgB,KAAK,IAAI,GAAG;AAC3C,sBAAY,YAAY;AACxB,iBAAO,KAAK,MAAM,MAAM,YAAY,KAAK,IAAI,IAAI,aAAa,IAAI,IAAI,IAAI;AAAA,QAC5E,OAAO;AAEL,iBAAO,KAAK,MAAM,KAAK,IAAI;AAAA,QAC7B;AAAA,MACF;AAEA,eAAS,IAAI,OAAO,YAAY,UAAU,cAAc;AAGtD,iBAAS,aAAaG,MAAK;AAAE,iBAAOA,QAAOA,KAAIA,KAAI,CAAC,MAAM,OAAO,IAAI,CAAC,MAAM;AAAA,QAAM;AAClF,iBAAS,kBAAkBA,MAAK;AAAE,iBAAOA,QAAO,CAAC,aAAaA,IAAG;AAAA,QAAG;AACpE,iBAAS,YAAYA,MAAKC,SAAQ,MAAM;AACtC,cAAI,CAACD;AAAK,mBAAO;AACjB,UAAAA,OAAM,OAAO,aAAaA,IAAG;AAC7B,cAAIF,IAAG,MAAME,KAAI;AACjB,eAAKF,KAAI,GAAGA,KAAI,OAAOE,KAAIF,EAAC,KAAK,KAAKA,MAAK;AAAA,UAAC;AAC5C,cAAI,QAAQA,KAAI;AAAG,YAAAE,OAAMA,KAAI,OAAOF,EAAC;AACrC,cAAIA,KAAI;AAAK,mBAAOG,UAAS,KAAK,MAAM,KAAKD,IAAG;AAAA;AAC3C,mBAAOA;AAAA,QACd;AAKA,YAAI,WAAW,OAAO,KAAK;AAC3B,YAAI,aAAa;AAAW,iBAAO,KAAK,MAAM,KAAK,QAAQ;AAE3D,gBAAQ,OAAO,OAAO;AAAA,UACpB,KAAK;AACH,mBAAO,MAAM,OAAO,KAAK,YAAY,YAAY;AAAA,UAEnD,KAAK;AAEH,mBAAO,SAAS,KAAK,IAAI,KAAK,MAAM,KAAK,OAAO,KAAK,CAAC,IAAI,KAAK,MAAM,KAAK,MAAM;AAAA,UAElF,KAAK;AACH,mBAAO,KAAK,MAAM,KAAK,OAAO,KAAK,CAAC;AAAA,UAEtC,KAAK;AAOH,gBAAI,CAAC;AAAO,qBAAO,KAAK,MAAM,KAAK,MAAM;AAEzC,gBAAIE;AACJ,gBAAI;AAAc,cAAAA,YAAW,OAAO,WAAW,KAAK;AAEpD,gBAAI,UAAU,OAAO,UAAU,SAAS,MAAM,KAAK,MAAM;AAGzD,gBAAI,OAAO;AACX,mBAAO;AACP,gBAAI,UAAU,MAAM;AACpB,gBAAI,SAAS,MAAM;AACnB,gBAAI,SAAS,YAAY,iBAAiB,KAAK;AAC/C,gBAAI,UAAU,CAAC;AACf,gBAAI;AAEJ,gBAAI,WAAW,WAAW,CAAC,IAAI;AAC/B,gBAAI,mBAAmB,cAAc,gBAAgB;AACrD,gBAAI,aAAa,YAAY,KAAK,MAAM,IAAI,CAAC;AAC7C,gBAAI,WAAW;AAEf,gBAAIJ,IAAG;AACP,gBAAIK,IAAG,GAAG;AACV,gBAAI,GAAG;AACP,gBAAIJ,MAAK;AAET,gBAAI,SAAS;AAIX,mBAAKD,KAAI,GAAG,SAAS,MAAM,QAAQA,KAAI,QAAQA,MAAK;AAClD,yBAASA,KAAI,SAAQ;AACrB,oBAAII,WAAU;AACZ,sBAAIA,UAAS,EAAEJ,EAAC,KAAG,CAAC;AACpB,uBAAK,kBAAkB,EAAE,CAAC,CAAC;AAC3B,0BAAQ,KAAK,YAAY,EAAE,CAAC,GAAG,IAAI,IAAI,MAAM;AAC7C,sBAAI,aAAa,EAAE,CAAC,KAAK,EAAE,CAAC,KAAK;AAAK,+BAAW;AAAA,gBACnD;AACK,0BAAQ,KAAK,MAAM;AACxB,0BAAU;AACV,oBAAI,MAAMA,EAAC;AACX,wBAAQ,KAAK,IAAI,GAAGI,YAAW,KAAK,OAAO,IAAI,KAAK,SAAS,YAAY,GAAG;AAC5E,oBAAI,UAAU;AAEZ,0BAAQ,OAAO,GAAG;AAAA,oBAChB,KAAK;AACH,gCAAU;AACV,qCAAe;AAAM,kCAAY;AACjC,+BAAS,KAAK,IAAI,GAAG,OAAO,IAAI,KAAK,SAAS,MAAM,IAAI,CAAC,IAAI,GAAG;AAChE,qCAAe;AAAkB,kCAAY;AAC7C;AAAA,oBACF,KAAK;AAAU,0BAAI,GAAG;AAAE,mCAAW;AAAM;AAAA,sBAAO;AAAA,oBAChD;AAAS,+BAAS,KAAK,QAAQ,QAAQ,SAAS,CAAC,KAAK,SAAS,aAAa,GAAG;AAAG;AAAA,kBACpF;AACA,sBAAI;AAAQ,+BAAW,MAAM,IAAI,CAAC,EAAE,SAAS,MAAM,IAAI,CAAC;AACxD,8BAAY;AAAA,gBACd;AACA,oBAAIA,aAAY,EAAE,CAAC;AAAG,0BAAQ,KAAK,YAAY,EAAE,CAAC,GAAG,KAAK,MAAM,MAAM,EAAE,CAAC;AAAA,cAC3E;AAEA,kBAAI,WAAW,GAAG;AAEhB,oBAAIA,aAAYA,UAAS;AAAG,0BAAQ,KAAK,YAAYA,UAAS,EAAE,CAAC,GAAG,IAAI,IAAI,OAAO;AAAA,cACrF;AACK,wBAAQ,KAAK,OAAO;AAKzB,kBAAI,QAAQ,WAAW;AAAG,gBAAAH,OAAM,KAAK,MAAM,KAAK,EAAE;AAAA,mBAC7C;AACH,gBAAAA,OAAM,SAAS,KAAK,MAAM,KAAK,QAAQ,KAAK,EAAE,CAAC;AAE/C,oBAAI,UAAU;AACZ,yBAAO,SAAS,KAAK,GAAG;AACxB,sBAAI,KAAK,SAAS,YAAY;AAAU,oBAAAA,OAAM,KAAK,MAAM,KAAK,IAAI;AAAA,gBACpE;AAAA,cACF;AAAA,YACF,OAAO;AAEL,kBAAI,cAAcG,YAAWA,UAAS,EAAE,MAAM,IAAI,CAAC;AACnD,kBAAI,aAAa,CAAC;AAClB,mBAAKC,MAAK,OAAO;AACf,oBAAI,OAAO,UAAU,eAAe,KAAK,OAAOA,EAAC,KAAK,YAAY,QAAQA,EAAC,IAAI;AAC7E,6BAAW,KAAKA,EAAC;AAAA,cACrB;AACA,kBAAG,WAAW;AACZ,2BAAW,KAAK;AAAA,cAClB;AACA,kBAAI,OAAO,YAAY,OAAO,UAAU;AAExC,mBAAKL,KAAI,GAAG,SAAS,KAAK,QAAQA,KAAI,QAAQA,MAAK;AACjD,yBAASA,KAAI,SAAS;AACtB,gBAAAK,KAAI,KAAKL,EAAC;AACV,oBAAII,WAAU;AACZ,sBAAIA,UAAS,EAAEC,EAAC,KAAG,CAAC;AACpB,uBAAK,kBAAkB,EAAE,CAAC,CAAC;AAC3B,0BAAQ,KAAK,YAAY,EAAE,CAAC,GAAG,IAAI,IAAI,MAAM;AAC7C,sBAAI,aAAa,EAAE,CAAC,KAAK,EAAE,CAAC,KAAK;AAAK,+BAAW;AAAA,gBACnD;AACK,0BAAQ,KAAK,MAAM;AAExB,0BAAU;AACV,oBAAI,MAAMA,EAAC;AACX,qBAAK,IAAI,GAAGD,aAAY,EAAE;AAC1B,wBAAQ,KAAK,SAASC,EAAC,IAAI,MAAM,IAAI,CAAC,KAAK,aAAa,EAAE,IAAI,KAAK,OAAO,MAAM,SAAS,YAAY,GAAG;AACxG,oBAAID,aAAY,EAAE,CAAC;AAAG,0BAAQ,KAAK,YAAY,EAAE,CAAC,GAAG,KAAK,MAAM,MAAM,EAAE,CAAC;AACzE,oBAAI,UAAU;AAEZ,0BAAQ,OAAO,GAAG;AAAA,oBAChB,KAAK;AACH,gCAAU;AACV,qCAAe;AAAM,kCAAY;AACjC,2BAAK,IAAI,GAAG,KAAK;AACjB,qCAAe;AAAkB,kCAAY;AAC7C,+BAAS,KAAK,SAASC,EAAC,IAAI,MAAM,IAAI,CAAC,IAAI,MAAM,MAAM,SAAS,MAAM,IAAI,CAAC,IAAI,GAAG;AAClF;AAAA,oBACF,KAAK;AAAU,0BAAI,GAAG;AAAE,mCAAW;AAAM;AAAA,sBAAO;AAAA,oBAChD;AAAS,+BAAS,KAAK,QAAQ,QAAQ,SAAS,CAAC,KAAK,SAAS,aAAa,GAAG;AAAG;AAAA,kBACpF;AACA,6BAAW,MAAM,IAAI,CAAC,EAAE,SAAS,MAAM,IAAI,CAAC;AAC5C,sBAAI;AAAQ,+BAAW,MAAM,IAAI,CAAC,EAAE,SAAS,MAAM,IAAI,CAAC;AACxD,8BAAY;AAAA,gBACd;AAAA,cACF;AACA,kBAAI,WAAW,GAAG;AAEhB,oBAAID,aAAYA,UAAS;AAAG,0BAAQ,KAAK,YAAYA,UAAS,EAAE,CAAC,GAAG,IAAI,IAAI,OAAO;AAAA,cACrF;AACK,wBAAQ,KAAK,OAAO;AAGzB,kBAAI,QAAQ,WAAW,GAAG;AACxB,gBAAAH,OAAM,KAAK,MAAM,KAAK,EAAE;AAAA,cAC1B,OAAO;AAEL,gBAAAA,OAAM,SAAS,KAAK,MAAM,KAAK,QAAQ,KAAK,EAAE,CAAC;AAE/C,oBAAI,UAAU;AACZ,yBAAO,SAAS,KAAK,GAAG;AACxB,sBAAI,KAAK,SAAS,YAAY;AAAU,oBAAAA,OAAM,KAAK,MAAM,KAAK,IAAI;AAAA,gBACpE;AAAA,cACF;AAAA,YACF;AAEA,kBAAM;AACN,mBAAOA;AAAA,QACX;AAAA,MACF;AAGA,eAAS,IAAI,QAAQ,QAAQ,WAAW;AAExC,UAAI,MAAM;AACV,UAAI,WAAW,eAAe,YAAY,OAAO,WAAW,IAAI,KAAK,CAAC,GAAG,IAAI;AAC7E,UAAI,YAAY,SAAS,CAAC;AAAG,cAAM,SAAS,CAAC,IAAI;AAGjD,aAAO,IAAI,MAAM,MAAM,MAAM,IAAI;AAEjC,UAAI;AAAU,eAAO,SAAS,CAAC,KAAG;AAElC,aAAO;AAAA,IACT;AAAA;AAAA;;;AC/YA;AAAA;AAAA;AAGA,QAAI,SAAO;AAEX,aAAS,YAAY,GAAG,GAAG,GAAG;AAC5B,UAAI;AACJ,UAAI;AAAG,YAAE,EAAE,EAAK;AAChB,UAAI;AAAG,SAAC,IAAE,KAAG,CAAC,GAAG,IAAE;AACnB,UAAI;AAAG,SAAC,IAAE,KAAG,CAAC,GAAG,IAAE;AACnB,aAAO;AAAA,IACT;AAEA,aAAS,gBAAgB,OAAO,MAAM;AAEpC,UAAI,UAAQ,QAAQ,OAAO,UAAQ;AAAU;AAC7C,UAAI,WAAS,OAAO,WAAW,KAAK;AACpC,UAAI;AAAU,eAAO,cAAc,KAAK;AAExC,UAAI,GAAG;AACP,UAAI,KAAK;AACT,UAAI,OAAO,UAAU,SAAS,MAAM,KAAK,MAAM,kBAAkB;AAC/D,cAAI,EAAE,GAAG,CAAC,EAAE;AACZ,aAAK,IAAE,GAAG,SAAO,MAAM,QAAQ,IAAE,QAAQ,KAAK;AAC5C,cAAI,YAAY,IAAI,GAAG,GAAG,SAAS,EAAE,CAAC,GAAG,gBAAgB,MAAM,CAAC,CAAC,CAAC;AAChE,kBAAI;AAAA,QACR;AACA,YAAI,CAAC,OAAO,SAAS,GAAE;AACrB,cAAI,IAAE,YAAY,SAAS,EAAE,CAAC,GAAG,SAAS,EAAE,CAAC,CAAC;AAC9C,gBAAI;AAAA,QACN;AAAA,MACF,OAAO;AACL,cAAI,EAAE,GAAG,CAAC,EAAE;AAGZ,YAAI,MAAM,cAAY,OAAO,KAAK,KAAK;AACvC,YAAI,YAAY,SAAS,GAAG;AAC1B,iBAAK,CAAC;AACN,mBAAS,EAAE,OAAO,WAAW,EAAE,QAAQ,SAASK,MAAK;AACnD,gBAAI,OAAO,UAAU,eAAe,KAAK,OAAOA,IAAG,KAAK,KAAK,QAAQA,IAAG,IAAE;AACxE,mBAAK,KAAKA,IAAG;AAAA,UACjB,CAAC;AAAA,QACH;AAAO,iBAAK;AACZ,YAAI,IAAE;AAGN,aAAK,IAAE,GAAG,SAAO,KAAK,QAAQ,IAAE,QAAQ,KAAK;AAC3C,cAAI,MAAI,KAAK,CAAC;AACd,cAAI,YAAY,IAAI,GAAG,KAAK,SAAS,EAAE,GAAG,GAAG,gBAAgB,MAAM,GAAG,CAAC,CAAC;AACtE,kBAAI;AAAA,QACR;AACA,YAAI,CAAC,OAAO,SAAS,GAAG;AACtB,cAAI,IAAE,YAAY,SAAS,EAAE,CAAC,GAAG,SAAS,EAAE,CAAC,CAAC;AAC9C,gBAAI;AAAA,QACN;AAAA,MACF;AAEA,UAAI,QAAQ,YAAY,SAAS,GAAG;AAClC,YAAI,IAAE,YAAY,SAAS,EAAE,CAAC,GAAG,SAAS,EAAE,CAAC,CAAC;AAAA,MAChD;AAEA,aAAO,MAAI,MAAI;AAAA,IACjB;AAEA,aAAS,WAAW;AAClB,UAAI,MAAI;AACR,OAAC,EAAE,QAAQ,KAAK,WAAW,SAAS,GAAG;AACrC,YAAI,KAAK,EAAE,KAAK,MAAI,IAAI;AACtB,cAAI;AAAK,mBAAK;AACd,iBAAK,EAAE,KAAK;AAAA,QACd;AAAA,MACF,CAAC;AACD,aAAO;AAAA,IACT;AAEA,aAAS,cAAc,UAAU,OAAO;AACtC,UAAI,UAAQ,CAAC;AACb,YAAM,UAAU,OAAO,SAAS,CAAC,CAAC;AAGlC,UAAI,QAAQ,SAAO,GAAG;AACpB,YAAI,OAAK,YAAY,OAAO,MAAM,CAAC;AACnC,gBAAM;AACN,gBAAQ,QAAQ,SAAS,GAAG;AAC1B,mBAAO,OAAK,EAAE,KAAK,KAAK,GAAG,IAAE,OAAK,SAAS,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,GAAG,QAAQ,MAAM,MAAM,IAAE;AAAA,QACnF,CAAC;AACD,oBAAY,OAAO,MAAM,CAAC;AAAA,MAC5B;AAAA,IACF;AAEA,aAAS,YAAY,KAAK,KAAK,MAAM,KAAK;AACxC,UAAI,IAAE,YAAY,OAAK,KAAK,CAAC,IAAE,QAAW,OAAK,KAAK,CAAC,IAAE,QAAW,GAAG;AACrE,UAAI;AAAG,YAAI,GAAG,IAAE;AAChB,aAAO;AAAA,IACT;AAEA,aAAS,eAAe,MAAM,GAAG;AAC/B,UAAI,MAAI,YAAY,EAAE,GAAG,EAAE,CAAC;AAC5B,UAAI,OAAK;AACT,aAAO;AAAA,IACT;AAEA,aAAS,QAAQ,UAAU,SAAS,MAAM;AAExC,UAAI,CAAC;AAAU;AAEf,UAAI,GAAG;AAEP,UAAI,SAAS,GAAG;AAEd,aAAK,IAAE,GAAG,SAAO,SAAS,EAAE,QAAQ,IAAE,QAAQ,KAAK;AACjD,cAAI,QAAM,KAAK,MAAM,EAAE,OAAO,CAAC,CAAC,CAAC;AACjC,cAAI,IAAE,SAAS,EAAE,CAAC;AAClB,cAAI,GAAG;AACL,oBAAQ,KAAK,eAAe,OAAO,CAAC,CAAC;AACrC,oBAAQ,EAAE,GAAG,SAAS,KAAK;AAAA,UAC7B;AAAA,QACF;AAAA,MACF,WAAW,SAAS,GAAG;AAErB,iBAAS,EAAE,QAAQ,SAAS,KAAK;AAC/B,cAAIC,SAAM,KAAK,MAAM,EAAE,OAAO,CAAC,GAAG,CAAC;AACnC,cAAIC,KAAE,SAAS,EAAE,GAAG;AACpB,cAAIA,IAAG;AACL,oBAAQ,KAAK,eAAeD,QAAOC,EAAC,CAAC;AACrC,oBAAQA,GAAE,GAAG,SAASD,MAAK;AAAA,UAC7B;AAAA,QACF,CAAC;AAAA,MACH;AAEA,UAAI,SAAS;AACX,gBAAQ,KAAK,eAAe,MAAM,SAAS,CAAC,CAAC;AAAA,IACjD;AAEA,aAAS,MAAM,UAAU,OAAO,SAAS,MAAM;AAE7C,UAAI,CAAC;AAAU;AACf,UAAI,UAAQ,QAAQ,OAAO,UAAQ,UAAU;AAC3C,gBAAQ,UAAU,SAAS,IAAI;AAC/B;AAAA,MACF;AAEA,UAAI;AACJ,UAAI,cAAY,OAAO,cAAc,KAAK;AAE1C,UAAI,KAAK,WAAS,KAAK,SAAS;AAC9B,oBAAY,IAAE,CAAC,SAAS,EAAE,GAAG,SAAS,EAAE,CAAC;AAE3C,UAAI,OAAO,UAAU,SAAS,MAAM,KAAK,MAAM,kBAAkB;AAC/D,oBAAY,IAAE,CAAC;AACf,YAAI,IAAE,SAAS,KAAG,CAAC;AACnB,iBAAS,OAAO,GAAG;AACjB,cAAI,EAAE,eAAe,GAAG,GAAG;AACzB,gBAAE,SAAS,GAAG;AACd,gBAAI,IAAE,SAAS,EAAE,GAAG;AACpB,gBAAI,GAAG;AACL,kBAAI,QAAM,KAAK,MAAM,EAAE,OAAO,CAAC,CAAC,CAAC;AACjC,kBAAI,IAAE,MAAM,QAAQ;AAClB,4BAAY,EAAE,CAAC,IAAE,CAAC,EAAE,GAAG,EAAE,CAAC;AAC1B,sBAAM,EAAE,GAAG,MAAM,CAAC,GAAG,SAAS,KAAK;AAAA,cACrC,OAAO;AACL,wBAAQ,KAAK,eAAe,OAAO,CAAC,CAAC;AACrC,wBAAQ,EAAE,GAAG,SAAS,KAAK;AAAA,cAC7B;AAAA,YACF;AAAA,UACF;AAAA,QACF;AACA,YAAI,MAAI,KAAK,SAAS;AAAG,sBAAY,IAAE,CAAC,SAAS,EAAE,GAAG,SAAS,EAAE,CAAC;AAAA,MACpE,OAAO;AACL,oBAAY,IAAE,CAAC;AACf,oBAAY,IAAE,CAAC;AACf,SAAC,SAAS,KAAG,CAAC,GAAG,QAAQ,SAASD,MAAK;AACrC,cAAIC,SAAM,KAAK,MAAM,EAAE,OAAO,CAACD,IAAG,CAAC;AACnC,cAAIE,KAAE,SAAS,EAAEF,IAAG;AACpB,cAAI,OAAO,UAAU,eAAe,KAAK,OAAOA,IAAG,GAAG;AACpD,wBAAY,EAAE,KAAKA,IAAG;AACtB,gBAAIE,IAAG;AACL,0BAAY,EAAEF,IAAG,IAAE,CAACE,GAAE,GAAGA,GAAE,CAAC;AAC5B,oBAAMA,GAAE,GAAG,MAAMF,IAAG,GAAG,SAASC,MAAK;AAAA,YACvC;AAAA,UACF,WAAWC,IAAG;AACZ,oBAAQ,KAAK,eAAeD,QAAOC,EAAC,CAAC;AACrC,oBAAQA,GAAE,GAAG,SAASD,MAAK;AAAA,UAC7B;AAAA,QACF,CAAC;AACD,YAAI,SAAS;AAAG,sBAAY,IAAE,CAAC,SAAS,EAAE,GAAG,SAAS,EAAE,CAAC;AAAA,MAC3D;AAAA,IACF;AAEA,aAAS,YAAY,OAAO,SAAS,QAAQ;AAC3C,UAAI,UAAQ,OAAO,cAAc,OAAO,OAAO,WAAW,KAAK,CAAC;AAChE,UAAI,CAAC,QAAQ;AAAG,gBAAQ,IAAE,CAAC,IAAI,EAAE;AACjC,UAAI,WAAW,YAAU;AAAI,gBAAQ,EAAE,MAAM,IAAE,OAAO,aAAa,OAAO;AAC1E,aAAO,QAAQ,EAAE,MAAM,KAAG;AAAA,IAC5B;AAEA,WAAO,UAAQ;AAAA,MACb,SAAS,SAAS,OAAO;AAAE,eAAO,gBAAgB,OAAO,IAAI;AAAA,MAAG;AAAA,MAChE,OAAO;AAAA,MACP,QAAQ,SAAS,OAAO,SAAS;AAAE,eAAO,YAAY,OAAO,SAAS,CAAC;AAAA,MAAG;AAAA,MAC1E,QAAQ,SAAS,OAAO,SAAS;AAAE,eAAO,YAAY,OAAO,SAAS,CAAC;AAAA,MAAG;AAAA,IAC5E;AAAA;AAAA;;;ACzMA;AAAA;AAmJA,QAAI,SAAS;AACb,QAAI,UAAU;AACd,QAAI,QAAQ;AACZ,QAAI,YAAY;AAChB,QAAI,WAAW;AACf,QAAI,MAAM;AAEV,WAAO,UAAQ;AAAA,MAEb;AAAA,MACA;AAAA,MAEA,WAAW,WAAW;AAAE,eAAO,OAAO;AAAA,MAAK;AAAA,MAC3C,cAAc,SAAS,KAAK;AAC1B,YAAI,QAAQ,QAAQ,QAAQ;AAAQ,iBAAO,MAAM;AAAA,MACnD;AAAA,MAEA;AAAA;AAAA,MAGA,IAAI;AAAA,QACF,OAAO,SAAS,MAAM,SAAS;AAC7B,WAAC,UAAQ,WAAS,CAAC,GAAG,UAAQ;AAC9B,iBAAO,MAAM,MAAM,OAAO;AAAA,QAC5B;AAAA,QACA,WAAW,SAAS,OAAO,SAAS;AAClC,WAAC,UAAQ,WAAS,CAAC,GAAG,UAAQ;AAC9B,iBAAO,UAAU,OAAO,OAAO;AAAA,QACjC;AAAA,MACF;AAAA,MAEA;AAAA,MAEA,KAAK,IAAI;AAAA,IAEX;AAAA;AAAA;",
  "names": ["string", "value", "ch", "array", "object", "gap", "i", "res", "str", "prefix", "comments", "k", "key", "kpath", "c"]
}
