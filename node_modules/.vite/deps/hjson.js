import {
  __commonJS
} from "./chunk-624QZG55.js";

// browser-external:os
var require_os = __commonJS({
  "browser-external:os"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "os" has been externalized for browser compatibility. Cannot access "os.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/hjson/lib/hjson-common.js
var require_hjson_common = __commonJS({
  "node_modules/hjson/lib/hjson-common.js"(exports, module) {
    "use strict";
    var os = require_os();
    function tryParseNumber(text, stopAtNext) {
      var number, string = "", leadingZeros = 0, testLeading = true;
      var at = 0;
      var ch;
      function next() {
        ch = text.charAt(at);
        at++;
        return ch;
      }
      next();
      if (ch === "-") {
        string = "-";
        next();
      }
      while (ch >= "0" && ch <= "9") {
        if (testLeading) {
          if (ch == "0")
            leadingZeros++;
          else
            testLeading = false;
        }
        string += ch;
        next();
      }
      if (testLeading)
        leadingZeros--;
      if (ch === ".") {
        string += ".";
        while (next() && ch >= "0" && ch <= "9")
          string += ch;
      }
      if (ch === "e" || ch === "E") {
        string += ch;
        next();
        if (ch === "-" || ch === "+") {
          string += ch;
          next();
        }
        while (ch >= "0" && ch <= "9") {
          string += ch;
          next();
        }
      }
      while (ch && ch <= " ")
        next();
      if (stopAtNext) {
        if (ch === "," || ch === "}" || ch === "]" || ch === "#" || ch === "/" && (text[at] === "/" || text[at] === "*"))
          ch = 0;
      }
      number = +string;
      if (ch || leadingZeros || !isFinite(number))
        return void 0;
      else
        return number;
    }
    function createComment(value, comment) {
      if (Object.defineProperty)
        Object.defineProperty(value, "__COMMENTS__", { enumerable: false, writable: true });
      return value.__COMMENTS__ = comment || {};
    }
    function removeComment(value) {
      Object.defineProperty(value, "__COMMENTS__", { value: void 0 });
    }
    function getComment(value) {
      return value.__COMMENTS__;
    }
    function forceComment(text) {
      if (!text)
        return "";
      var a = text.split("\n");
      var str, i, j, len;
      for (j = 0; j < a.length; j++) {
        str = a[j];
        len = str.length;
        for (i = 0; i < len; i++) {
          var c = str[i];
          if (c === "#")
            break;
          else if (c === "/" && (str[i + 1] === "/" || str[i + 1] === "*")) {
            if (str[i + 1] === "*")
              j = a.length;
            break;
          } else if (c > " ") {
            a[j] = "# " + str;
            break;
          }
        }
      }
      return a.join("\n");
    }
    module.exports = {
      EOL: os.EOL || "\n",
      tryParseNumber,
      createComment,
      removeComment,
      getComment,
      forceComment
    };
  }
});

// node_modules/hjson/lib/hjson-version.js
var require_hjson_version = __commonJS({
  "node_modules/hjson/lib/hjson-version.js"(exports, module) {
    module.exports = "3.2.1";
  }
});

// node_modules/hjson/lib/hjson-dsf.js
var require_hjson_dsf = __commonJS({
  "node_modules/hjson/lib/hjson-dsf.js"(exports, module) {
    "use strict";
    function loadDsf(col, type) {
      if (Object.prototype.toString.apply(col) !== "[object Array]") {
        if (col)
          throw new Error("dsf option must contain an array!");
        else
          return nopDsf;
      } else if (col.length === 0)
        return nopDsf;
      var dsf = [];
      function isFunction(f) {
        return {}.toString.call(f) === "[object Function]";
      }
      col.forEach(function(x) {
        if (!x.name || !isFunction(x.parse) || !isFunction(x.stringify))
          throw new Error("extension does not match the DSF interface");
        dsf.push(function() {
          try {
            if (type == "parse") {
              return x.parse.apply(null, arguments);
            } else if (type == "stringify") {
              var res = x.stringify.apply(null, arguments);
              if (res !== void 0 && (typeof res !== "string" || res.length === 0 || res[0] === '"' || [].some.call(res, function(c) {
                return isInvalidDsfChar(c);
              })))
                throw new Error("value may not be empty, start with a quote or contain a punctuator character except colon: " + res);
              return res;
            } else
              throw new Error("Invalid type");
          } catch (e) {
            throw new Error("DSF-" + x.name + " failed; " + e.message);
          }
        });
      });
      return runDsf.bind(null, dsf);
    }
    function runDsf(dsf, value) {
      if (dsf) {
        for (var i = 0; i < dsf.length; i++) {
          var res = dsf[i](value);
          if (res !== void 0)
            return res;
        }
      }
    }
    function nopDsf() {
    }
    function isInvalidDsfChar(c) {
      return c === "{" || c === "}" || c === "[" || c === "]" || c === ",";
    }
    function math() {
      return {
        name: "math",
        parse: function(value) {
          switch (value) {
            case "+inf":
            case "inf":
            case "+Inf":
            case "Inf":
              return Infinity;
            case "-inf":
            case "-Inf":
              return -Infinity;
            case "nan":
            case "NaN":
              return NaN;
          }
        },
        stringify: function(value) {
          if (typeof value !== "number")
            return;
          if (1 / value === -Infinity)
            return "-0";
          if (value === Infinity)
            return "Inf";
          if (value === -Infinity)
            return "-Inf";
          if (isNaN(value))
            return "NaN";
        }
      };
    }
    math.description = "support for Inf/inf, -Inf/-inf, Nan/naN and -0";
    function hex(opt) {
      var out = opt && opt.out;
      return {
        name: "hex",
        parse: function(value) {
          if (/^0x[0-9A-Fa-f]+$/.test(value))
            return parseInt(value, 16);
        },
        stringify: function(value) {
          if (out && Number.isInteger(value))
            return "0x" + value.toString(16);
        }
      };
    }
    hex.description = "parse hexadecimal numbers prefixed with 0x";
    function date() {
      return {
        name: "date",
        parse: function(value) {
          if (/^\d{4}-\d{2}-\d{2}$/.test(value) || /^\d{4}-\d{2}-\d{2}T\d{2}\:\d{2}\:\d{2}(?:.\d+)(?:Z|[+-]\d{2}:\d{2})$/.test(value)) {
            var dt = Date.parse(value);
            if (!isNaN(dt))
              return new Date(dt);
          }
        },
        stringify: function(value) {
          if (Object.prototype.toString.call(value) === "[object Date]") {
            var dt = value.toISOString();
            if (dt.indexOf("T00:00:00.000Z", dt.length - 14) !== -1)
              return dt.substr(0, 10);
            else
              return dt;
          }
        }
      };
    }
    date.description = "support ISO dates";
    module.exports = {
      loadDsf,
      std: {
        math,
        hex,
        date
      }
    };
  }
});

// node_modules/hjson/lib/hjson-parse.js
var require_hjson_parse = __commonJS({
  "node_modules/hjson/lib/hjson-parse.js"(exports, module) {
    "use strict";
    module.exports = function(source, opt) {
      var common = require_hjson_common();
      var dsf = require_hjson_dsf();
      var text;
      var at;
      var ch;
      var escapee = {
        '"': '"',
        "'": "'",
        "\\": "\\",
        "/": "/",
        b: "\b",
        f: "\f",
        n: "\n",
        r: "\r",
        t: "	"
      };
      var keepComments;
      var runDsf;
      function resetAt() {
        at = 0;
        ch = " ";
      }
      function isPunctuatorChar(c) {
        return c === "{" || c === "}" || c === "[" || c === "]" || c === "," || c === ":";
      }
      function error(m) {
        var i, col = 0, line = 1;
        for (i = at - 1; i > 0 && text[i] !== "\n"; i--, col++) {
        }
        for (; i > 0; i--)
          if (text[i] === "\n")
            line++;
        throw new Error(m + " at line " + line + "," + col + " >>>" + text.substr(at - col, 20) + " ...");
      }
      function next() {
        ch = text.charAt(at);
        at++;
        return ch;
      }
      function peek(offs) {
        return text.charAt(at + offs);
      }
      function string(allowML) {
        var string2 = "";
        var exitCh = ch;
        while (next()) {
          if (ch === exitCh) {
            next();
            if (allowML && exitCh === "'" && ch === "'" && string2.length === 0) {
              next();
              return mlString();
            } else
              return string2;
          }
          if (ch === "\\") {
            next();
            if (ch === "u") {
              var uffff = 0;
              for (var i = 0; i < 4; i++) {
                next();
                var c = ch.charCodeAt(0), hex;
                if (ch >= "0" && ch <= "9")
                  hex = c - 48;
                else if (ch >= "a" && ch <= "f")
                  hex = c - 97 + 10;
                else if (ch >= "A" && ch <= "F")
                  hex = c - 65 + 10;
                else
                  error("Bad \\u char " + ch);
                uffff = uffff * 16 + hex;
              }
              string2 += String.fromCharCode(uffff);
            } else if (typeof escapee[ch] === "string") {
              string2 += escapee[ch];
            } else
              break;
          } else if (ch === "\n" || ch === "\r") {
            error("Bad string containing newline");
          } else {
            string2 += ch;
          }
        }
        error("Bad string");
      }
      function mlString() {
        var string2 = "", triple = 0;
        var indent = 0;
        for (; ; ) {
          var c = peek(-indent - 5);
          if (!c || c === "\n")
            break;
          indent++;
        }
        function skipIndent() {
          var skip = indent;
          while (ch && ch <= " " && ch !== "\n" && skip-- > 0)
            next();
        }
        while (ch && ch <= " " && ch !== "\n")
          next();
        if (ch === "\n") {
          next();
          skipIndent();
        }
        for (; ; ) {
          if (!ch) {
            error("Bad multiline string");
          } else if (ch === "'") {
            triple++;
            next();
            if (triple === 3) {
              if (string2.slice(-1) === "\n")
                string2 = string2.slice(0, -1);
              return string2;
            } else
              continue;
          } else {
            while (triple > 0) {
              string2 += "'";
              triple--;
            }
          }
          if (ch === "\n") {
            string2 += "\n";
            next();
            skipIndent();
          } else {
            if (ch !== "\r")
              string2 += ch;
            next();
          }
        }
      }
      function keyname() {
        if (ch === '"' || ch === "'")
          return string(false);
        var name = "", start = at, space = -1;
        for (; ; ) {
          if (ch === ":") {
            if (!name)
              error("Found ':' but no key name (for an empty key name use quotes)");
            else if (space >= 0 && space !== name.length) {
              at = start + space;
              error("Found whitespace in your key name (use quotes to include)");
            }
            return name;
          } else if (ch <= " ") {
            if (!ch)
              error("Found EOF while looking for a key name (check your syntax)");
            else if (space < 0)
              space = name.length;
          } else if (isPunctuatorChar(ch)) {
            error("Found '" + ch + "' where a key name was expected (check your syntax or use quotes if the key name includes {}[],: or whitespace)");
          } else {
            name += ch;
          }
          next();
        }
      }
      function white() {
        while (ch) {
          while (ch && ch <= " ")
            next();
          if (ch === "#" || ch === "/" && peek(0) === "/") {
            while (ch && ch !== "\n")
              next();
          } else if (ch === "/" && peek(0) === "*") {
            next();
            next();
            while (ch && !(ch === "*" && peek(0) === "/"))
              next();
            if (ch) {
              next();
              next();
            }
          } else
            break;
        }
      }
      function tfnns() {
        var value2 = ch;
        if (isPunctuatorChar(ch))
          error("Found a punctuator character '" + ch + "' when expecting a quoteless string (check your syntax)");
        for (; ; ) {
          next();
          var isEol = ch === "\r" || ch === "\n" || ch === "";
          if (isEol || ch === "," || ch === "}" || ch === "]" || ch === "#" || ch === "/" && (peek(0) === "/" || peek(0) === "*")) {
            var chf = value2[0];
            switch (chf) {
              case "f":
                if (value2.trim() === "false")
                  return false;
                break;
              case "n":
                if (value2.trim() === "null")
                  return null;
                break;
              case "t":
                if (value2.trim() === "true")
                  return true;
                break;
              default:
                if (chf === "-" || chf >= "0" && chf <= "9") {
                  var n = common.tryParseNumber(value2);
                  if (n !== void 0)
                    return n;
                }
            }
            if (isEol) {
              value2 = value2.trim();
              var dsfValue = runDsf(value2);
              return dsfValue !== void 0 ? dsfValue : value2;
            }
          }
          value2 += ch;
        }
      }
      function getComment(cAt, first) {
        var i;
        cAt--;
        for (i = at - 2; i > cAt && text[i] <= " " && text[i] !== "\n"; i--)
          ;
        if (text[i] === "\n")
          i--;
        if (text[i] === "\r")
          i--;
        var res = text.substr(cAt, i - cAt + 1);
        for (i = 0; i < res.length; i++) {
          if (res[i] > " ") {
            var j = res.indexOf("\n");
            if (j >= 0) {
              var c = [res.substr(0, j), res.substr(j + 1)];
              if (first && c[0].trim().length === 0)
                c.shift();
              return c;
            } else
              return [res];
          }
        }
        return [];
      }
      function errorClosingHint(value2) {
        function search(value3, ch2) {
          var i, k, length, res;
          switch (typeof value3) {
            case "string":
              if (value3.indexOf(ch2) >= 0)
                res = value3;
              break;
            case "object":
              if (Object.prototype.toString.apply(value3) === "[object Array]") {
                for (i = 0, length = value3.length; i < length; i++) {
                  res = search(value3[i], ch2) || res;
                }
              } else {
                for (k in value3) {
                  if (!Object.prototype.hasOwnProperty.call(value3, k))
                    continue;
                  res = search(value3[k], ch2) || res;
                }
              }
          }
          return res;
        }
        function report(ch2) {
          var possibleErr = search(value2, ch2);
          if (possibleErr) {
            return "found '" + ch2 + "' in a string value, your mistake could be with:\n  > " + possibleErr + "\n  (unquoted strings contain everything up to the next line!)";
          } else
            return "";
        }
        return report("}") || report("]");
      }
      function array() {
        var array2 = [];
        var comments, cAt, nextComment;
        try {
          if (keepComments)
            comments = common.createComment(array2, { a: [] });
          next();
          cAt = at;
          white();
          if (comments)
            nextComment = getComment(cAt, true).join("\n");
          if (ch === "]") {
            next();
            if (comments)
              comments.e = [nextComment];
            return array2;
          }
          while (ch) {
            array2.push(value());
            cAt = at;
            white();
            if (ch === ",") {
              next();
              cAt = at;
              white();
            }
            if (comments) {
              var c = getComment(cAt);
              comments.a.push([nextComment || "", c[0] || ""]);
              nextComment = c[1];
            }
            if (ch === "]") {
              next();
              if (comments)
                comments.a[comments.a.length - 1][1] += nextComment || "";
              return array2;
            }
            white();
          }
          error("End of input while parsing an array (missing ']')");
        } catch (e) {
          e.hint = e.hint || errorClosingHint(array2);
          throw e;
        }
      }
      function object(withoutBraces) {
        var key = "", object2 = {};
        var comments, cAt, nextComment;
        try {
          if (keepComments)
            comments = common.createComment(object2, { c: {}, o: [] });
          if (!withoutBraces) {
            next();
            cAt = at;
          } else
            cAt = 1;
          white();
          if (comments)
            nextComment = getComment(cAt, true).join("\n");
          if (ch === "}" && !withoutBraces) {
            if (comments)
              comments.e = [nextComment];
            next();
            return object2;
          }
          while (ch) {
            key = keyname();
            white();
            if (ch !== ":")
              error("Expected ':' instead of '" + ch + "'");
            next();
            object2[key] = value();
            cAt = at;
            white();
            if (ch === ",") {
              next();
              cAt = at;
              white();
            }
            if (comments) {
              var c = getComment(cAt);
              comments.c[key] = [nextComment || "", c[0] || ""];
              nextComment = c[1];
              comments.o.push(key);
            }
            if (ch === "}" && !withoutBraces) {
              next();
              if (comments)
                comments.c[key][1] += nextComment || "";
              return object2;
            }
            white();
          }
          if (withoutBraces)
            return object2;
          else
            error("End of input while parsing an object (missing '}')");
        } catch (e) {
          e.hint = e.hint || errorClosingHint(object2);
          throw e;
        }
      }
      function value() {
        white();
        switch (ch) {
          case "{":
            return object();
          case "[":
            return array();
          case "'":
          case '"':
            return string(true);
          default:
            return tfnns();
        }
      }
      function checkTrailing(v, c) {
        var cAt = at;
        white();
        if (ch)
          error("Syntax error, found trailing characters");
        if (keepComments) {
          var b = c.join("\n"), a = getComment(cAt).join("\n");
          if (a || b) {
            var comments = common.createComment(v, common.getComment(v));
            comments.r = [b, a];
          }
        }
        return v;
      }
      function rootValue() {
        white();
        var c = keepComments ? getComment(1) : null;
        switch (ch) {
          case "{":
            return checkTrailing(object(), c);
          case "[":
            return checkTrailing(array(), c);
          default:
            return checkTrailing(value(), c);
        }
      }
      function legacyRootValue() {
        white();
        var c = keepComments ? getComment(1) : null;
        switch (ch) {
          case "{":
            return checkTrailing(object(), c);
          case "[":
            return checkTrailing(array(), c);
        }
        try {
          return checkTrailing(object(true), c);
        } catch (e) {
          resetAt();
          try {
            return checkTrailing(value(), c);
          } catch (e2) {
            throw e;
          }
        }
      }
      if (typeof source !== "string")
        throw new Error("source is not a string");
      var dsfDef = null;
      var legacyRoot = true;
      if (opt && typeof opt === "object") {
        keepComments = opt.keepWsc;
        dsfDef = opt.dsf;
        legacyRoot = opt.legacyRoot !== false;
      }
      runDsf = dsf.loadDsf(dsfDef, "parse");
      text = source;
      resetAt();
      return legacyRoot ? legacyRootValue() : rootValue();
    };
  }
});

// node_modules/hjson/lib/hjson-stringify.js
var require_hjson_stringify = __commonJS({
  "node_modules/hjson/lib/hjson-stringify.js"(exports, module) {
    "use strict";
    module.exports = function(data, opt) {
      var common = require_hjson_common();
      var dsf = require_hjson_dsf();
      var plainToken = {
        obj: ["{", "}"],
        arr: ["[", "]"],
        key: ["", ""],
        qkey: ['"', '"'],
        col: [":", ""],
        com: [",", ""],
        str: ["", ""],
        qstr: ['"', '"'],
        mstr: ["'''", "'''"],
        num: ["", ""],
        lit: ["", ""],
        dsf: ["", ""],
        esc: ["\\", ""],
        uni: ["\\u", ""],
        rem: ["", ""]
      };
      var eol = common.EOL;
      var indent = "  ";
      var keepComments = false;
      var bracesSameLine = false;
      var quoteKeys = false;
      var quoteStrings = false;
      var condense = 0;
      var multiline = 1;
      var separator = "";
      var dsfDef = null;
      var sortProps = false;
      var token = plainToken;
      if (opt && typeof opt === "object") {
        opt.quotes = opt.quotes === "always" ? "strings" : opt.quotes;
        if (opt.eol === "\n" || opt.eol === "\r\n")
          eol = opt.eol;
        keepComments = opt.keepWsc;
        condense = opt.condense || 0;
        bracesSameLine = opt.bracesSameLine;
        quoteKeys = opt.quotes === "all" || opt.quotes === "keys";
        quoteStrings = opt.quotes === "all" || opt.quotes === "strings" || opt.separator === true;
        if (quoteStrings || opt.multiline == "off")
          multiline = 0;
        else
          multiline = opt.multiline == "no-tabs" ? 2 : 1;
        separator = opt.separator === true ? token.com[0] : "";
        dsfDef = opt.dsf;
        sortProps = opt.sortProps;
        if (typeof opt.space === "number") {
          indent = new Array(opt.space + 1).join(" ");
        } else if (typeof opt.space === "string") {
          indent = opt.space;
        }
        if (opt.colors === true) {
          token = {
            obj: ["\x1B[37m{\x1B[0m", "\x1B[37m}\x1B[0m"],
            arr: ["\x1B[37m[\x1B[0m", "\x1B[37m]\x1B[0m"],
            key: ["\x1B[33m", "\x1B[0m"],
            qkey: ['\x1B[33m"', '"\x1B[0m'],
            col: ["\x1B[37m:\x1B[0m", ""],
            com: ["\x1B[37m,\x1B[0m", ""],
            str: ["\x1B[37;1m", "\x1B[0m"],
            qstr: ['\x1B[37;1m"', '"\x1B[0m'],
            mstr: ["\x1B[37;1m'''", "'''\x1B[0m"],
            num: ["\x1B[36;1m", "\x1B[0m"],
            lit: ["\x1B[36m", "\x1B[0m"],
            dsf: ["\x1B[37m", "\x1B[0m"],
            esc: ["\x1B[31m\\", "\x1B[0m"],
            uni: ["\x1B[31m\\u", "\x1B[0m"],
            rem: ["\x1B[35m", "\x1B[0m"]
          };
        }
        var i, ckeys = Object.keys(plainToken);
        for (i = ckeys.length - 1; i >= 0; i--) {
          var k = ckeys[i];
          token[k].push(plainToken[k][0].length, plainToken[k][1].length);
        }
      }
      var runDsf;
      var commonRange = "-¬ü¬≠ÿÄ-ÿÑ‹è·û¥·ûµ‚Äå-‚Äè\u2028-‚ÄØ‚Å†-‚ÅØ\uFEFFÔø∞-Ôøø";
      var needsEscape = new RegExp('[\\\\\\"\0-' + commonRange + "]", "g");
      var needsQuotes = new RegExp(`^\\s|^"|^'|^#|^\\/\\*|^\\/\\/|^\\{|^\\}|^\\[|^\\]|^:|^,|\\s$|[\0-` + commonRange + "]", "g");
      var needsEscapeML = new RegExp("'''|^[\\s]+$|[\0-" + (multiline === 2 ? "	" : "\b") + "\v\f-" + commonRange + "]", "g");
      var startsWithKeyword = new RegExp("^(true|false|null)\\s*((,|\\]|\\}|#|//|/\\*).*)?$");
      var meta = {
        // table of character substitutions
        "\b": "b",
        "	": "t",
        "\n": "n",
        "\f": "f",
        "\r": "r",
        '"': '"',
        "\\": "\\"
      };
      var needsEscapeName = /[,\{\[\}\]\s:#"']|\/\/|\/\*/;
      var gap = "";
      var wrapLen = 0;
      function wrap(tk, v) {
        wrapLen += tk[0].length + tk[1].length - tk[2] - tk[3];
        return tk[0] + v + tk[1];
      }
      function quoteReplace(string) {
        return string.replace(needsEscape, function(a) {
          var c = meta[a];
          if (typeof c === "string")
            return wrap(token.esc, c);
          else
            return wrap(token.uni, ("0000" + a.charCodeAt(0).toString(16)).slice(-4));
        });
      }
      function quote(string, gap2, hasComment, isRootObject) {
        if (!string)
          return wrap(token.qstr, "");
        needsQuotes.lastIndex = 0;
        startsWithKeyword.lastIndex = 0;
        if (quoteStrings || hasComment || needsQuotes.test(string) || common.tryParseNumber(string, true) !== void 0 || startsWithKeyword.test(string)) {
          needsEscape.lastIndex = 0;
          needsEscapeML.lastIndex = 0;
          if (!needsEscape.test(string))
            return wrap(token.qstr, string);
          else if (!needsEscapeML.test(string) && !isRootObject && multiline)
            return mlString(string, gap2);
          else
            return wrap(token.qstr, quoteReplace(string));
        } else {
          return wrap(token.str, string);
        }
      }
      function mlString(string, gap2) {
        var i2, a = string.replace(/\r/g, "").split("\n");
        gap2 += indent;
        if (a.length === 1) {
          return wrap(token.mstr, a[0]);
        } else {
          var res2 = eol + gap2 + token.mstr[0];
          for (i2 = 0; i2 < a.length; i2++) {
            res2 += eol;
            if (a[i2])
              res2 += gap2 + a[i2];
          }
          return res2 + eol + gap2 + token.mstr[1];
        }
      }
      function quoteKey(name) {
        if (!name)
          return '""';
        if (quoteKeys || needsEscapeName.test(name)) {
          needsEscape.lastIndex = 0;
          return wrap(token.qkey, needsEscape.test(name) ? quoteReplace(name) : name);
        } else {
          return wrap(token.key, name);
        }
      }
      function str(value, hasComment, noIndent, isRootObject) {
        function startsWithNL(str2) {
          return str2 && str2[str2[0] === "\r" ? 1 : 0] === "\n";
        }
        function commentOnThisLine(str2) {
          return str2 && !startsWithNL(str2);
        }
        function makeComment(str2, prefix2, trim) {
          if (!str2)
            return "";
          str2 = common.forceComment(str2);
          var i3, len = str2.length;
          for (i3 = 0; i3 < len && str2[i3] <= " "; i3++) {
          }
          if (trim && i3 > 0)
            str2 = str2.substr(i3);
          if (i3 < len)
            return prefix2 + wrap(token.rem, str2);
          else
            return str2;
        }
        var dsfValue = runDsf(value);
        if (dsfValue !== void 0)
          return wrap(token.dsf, dsfValue);
        switch (typeof value) {
          case "string":
            return quote(value, gap, hasComment, isRootObject);
          case "number":
            return isFinite(value) ? wrap(token.num, String(value)) : wrap(token.lit, "null");
          case "boolean":
            return wrap(token.lit, String(value));
          case "object":
            if (!value)
              return wrap(token.lit, "null");
            var comments2;
            if (keepComments)
              comments2 = common.getComment(value);
            var isArray = Object.prototype.toString.apply(value) === "[object Array]";
            var mind = gap;
            gap += indent;
            var eolMind = eol + mind;
            var eolGap = eol + gap;
            var prefix = noIndent || bracesSameLine ? "" : eolMind;
            var partial = [];
            var setsep;
            var cpartial = condense ? [] : null;
            var saveQuoteStrings = quoteStrings, saveMultiline = multiline;
            var iseparator = separator ? "" : token.com[0];
            var cwrapLen = 0;
            var i2, length;
            var k2, v, vs;
            var c, ca;
            var res2, cres;
            if (isArray) {
              for (i2 = 0, length = value.length; i2 < length; i2++) {
                setsep = i2 < length - 1;
                if (comments2) {
                  c = comments2.a[i2] || [];
                  ca = commentOnThisLine(c[1]);
                  partial.push(makeComment(c[0], "\n") + eolGap);
                  if (cpartial && (c[0] || c[1] || ca))
                    cpartial = null;
                } else
                  partial.push(eolGap);
                wrapLen = 0;
                v = value[i2];
                partial.push(str(v, comments2 ? ca : false, true) + (setsep ? separator : ""));
                if (cpartial) {
                  switch (typeof v) {
                    case "string":
                      wrapLen = 0;
                      quoteStrings = true;
                      multiline = 0;
                      cpartial.push(str(v, false, true) + (setsep ? token.com[0] : ""));
                      quoteStrings = saveQuoteStrings;
                      multiline = saveMultiline;
                      break;
                    case "object":
                      if (v) {
                        cpartial = null;
                        break;
                      }
                    default:
                      cpartial.push(partial[partial.length - 1] + (setsep ? iseparator : ""));
                      break;
                  }
                  if (setsep)
                    wrapLen += token.com[0].length - token.com[2];
                  cwrapLen += wrapLen;
                }
                if (comments2 && c[1])
                  partial.push(makeComment(c[1], ca ? " " : "\n", ca));
              }
              if (length === 0) {
                if (comments2 && comments2.e)
                  partial.push(makeComment(comments2.e[0], "\n") + eolMind);
              } else
                partial.push(eolMind);
              if (partial.length === 0)
                res2 = wrap(token.arr, "");
              else {
                res2 = prefix + wrap(token.arr, partial.join(""));
                if (cpartial) {
                  cres = cpartial.join(" ");
                  if (cres.length - cwrapLen <= condense)
                    res2 = wrap(token.arr, cres);
                }
              }
            } else {
              var commentKeys = comments2 ? comments2.o.slice() : [];
              var objectKeys = [];
              for (k2 in value) {
                if (Object.prototype.hasOwnProperty.call(value, k2) && commentKeys.indexOf(k2) < 0)
                  objectKeys.push(k2);
              }
              if (sortProps) {
                objectKeys.sort();
              }
              var keys = commentKeys.concat(objectKeys);
              for (i2 = 0, length = keys.length; i2 < length; i2++) {
                setsep = i2 < length - 1;
                k2 = keys[i2];
                if (comments2) {
                  c = comments2.c[k2] || [];
                  ca = commentOnThisLine(c[1]);
                  partial.push(makeComment(c[0], "\n") + eolGap);
                  if (cpartial && (c[0] || c[1] || ca))
                    cpartial = null;
                } else
                  partial.push(eolGap);
                wrapLen = 0;
                v = value[k2];
                vs = str(v, comments2 && ca);
                partial.push(quoteKey(k2) + token.col[0] + (startsWithNL(vs) ? "" : " ") + vs + (setsep ? separator : ""));
                if (comments2 && c[1])
                  partial.push(makeComment(c[1], ca ? " " : "\n", ca));
                if (cpartial) {
                  switch (typeof v) {
                    case "string":
                      wrapLen = 0;
                      quoteStrings = true;
                      multiline = 0;
                      vs = str(v, false);
                      quoteStrings = saveQuoteStrings;
                      multiline = saveMultiline;
                      cpartial.push(quoteKey(k2) + token.col[0] + " " + vs + (setsep ? token.com[0] : ""));
                      break;
                    case "object":
                      if (v) {
                        cpartial = null;
                        break;
                      }
                    default:
                      cpartial.push(partial[partial.length - 1] + (setsep ? iseparator : ""));
                      break;
                  }
                  wrapLen += token.col[0].length - token.col[2];
                  if (setsep)
                    wrapLen += token.com[0].length - token.com[2];
                  cwrapLen += wrapLen;
                }
              }
              if (length === 0) {
                if (comments2 && comments2.e)
                  partial.push(makeComment(comments2.e[0], "\n") + eolMind);
              } else
                partial.push(eolMind);
              if (partial.length === 0) {
                res2 = wrap(token.obj, "");
              } else {
                res2 = prefix + wrap(token.obj, partial.join(""));
                if (cpartial) {
                  cres = cpartial.join(" ");
                  if (cres.length - cwrapLen <= condense)
                    res2 = wrap(token.obj, cres);
                }
              }
            }
            gap = mind;
            return res2;
        }
      }
      runDsf = dsf.loadDsf(dsfDef, "stringify");
      var res = "";
      var comments = keepComments ? comments = (common.getComment(data) || {}).r : null;
      if (comments && comments[0])
        res = comments[0] + "\n";
      res += str(data, null, true, true);
      if (comments)
        res += comments[1] || "";
      return res;
    };
  }
});

// node_modules/hjson/lib/hjson-comments.js
var require_hjson_comments = __commonJS({
  "node_modules/hjson/lib/hjson-comments.js"(exports, module) {
    "use strict";
    var common = require_hjson_common();
    function makeComment(b, a, x) {
      var c;
      if (b)
        c = { b };
      if (a)
        (c = c || {}).a = a;
      if (x)
        (c = c || {}).x = x;
      return c;
    }
    function extractComments(value, root) {
      if (value === null || typeof value !== "object")
        return;
      var comments = common.getComment(value);
      if (comments)
        common.removeComment(value);
      var i, length;
      var any, res;
      if (Object.prototype.toString.apply(value) === "[object Array]") {
        res = { a: {} };
        for (i = 0, length = value.length; i < length; i++) {
          if (saveComment(res.a, i, comments.a[i], extractComments(value[i])))
            any = true;
        }
        if (!any && comments.e) {
          res.e = makeComment(comments.e[0], comments.e[1]);
          any = true;
        }
      } else {
        res = { s: {} };
        var keys, currentKeys = Object.keys(value);
        if (comments && comments.o) {
          keys = [];
          comments.o.concat(currentKeys).forEach(function(key2) {
            if (Object.prototype.hasOwnProperty.call(value, key2) && keys.indexOf(key2) < 0)
              keys.push(key2);
          });
        } else
          keys = currentKeys;
        res.o = keys;
        for (i = 0, length = keys.length; i < length; i++) {
          var key = keys[i];
          if (saveComment(res.s, key, comments.c[key], extractComments(value[key])))
            any = true;
        }
        if (!any && comments.e) {
          res.e = makeComment(comments.e[0], comments.e[1]);
          any = true;
        }
      }
      if (root && comments && comments.r) {
        res.r = makeComment(comments.r[0], comments.r[1]);
      }
      return any ? res : void 0;
    }
    function mergeStr() {
      var res = "";
      [].forEach.call(arguments, function(c) {
        if (c && c.trim() !== "") {
          if (res)
            res += "; ";
          res += c.trim();
        }
      });
      return res;
    }
    function mergeComments(comments, value) {
      var dropped = [];
      merge(comments, value, dropped, []);
      if (dropped.length > 0) {
        var text = rootComment(value, null, 1);
        text += "\n# Orphaned comments:\n";
        dropped.forEach(function(c) {
          text += ("# " + c.path.join("/") + ": " + mergeStr(c.b, c.a, c.e)).replace("\n", "\\n ") + "\n";
        });
        rootComment(value, text, 1);
      }
    }
    function saveComment(res, key, item, col) {
      var c = makeComment(item ? item[0] : void 0, item ? item[1] : void 0, col);
      if (c)
        res[key] = c;
      return c;
    }
    function droppedComment(path, c) {
      var res = makeComment(c.b, c.a);
      res.path = path;
      return res;
    }
    function dropAll(comments, dropped, path) {
      if (!comments)
        return;
      var i, length;
      if (comments.a) {
        for (i = 0, length = comments.a.length; i < length; i++) {
          var kpath = path.slice().concat([i]);
          var c = comments.a[i];
          if (c) {
            dropped.push(droppedComment(kpath, c));
            dropAll(c.x, dropped, kpath);
          }
        }
      } else if (comments.o) {
        comments.o.forEach(function(key) {
          var kpath2 = path.slice().concat([key]);
          var c2 = comments.s[key];
          if (c2) {
            dropped.push(droppedComment(kpath2, c2));
            dropAll(c2.x, dropped, kpath2);
          }
        });
      }
      if (comments.e)
        dropped.push(droppedComment(path, comments.e));
    }
    function merge(comments, value, dropped, path) {
      if (!comments)
        return;
      if (value === null || typeof value !== "object") {
        dropAll(comments, dropped, path);
        return;
      }
      var i;
      var setComments = common.createComment(value);
      if (path.length === 0 && comments.r)
        setComments.r = [comments.r.b, comments.r.a];
      if (Object.prototype.toString.apply(value) === "[object Array]") {
        setComments.a = [];
        var a = comments.a || {};
        for (var key in a) {
          if (a.hasOwnProperty(key)) {
            i = parseInt(key);
            var c = comments.a[key];
            if (c) {
              var kpath = path.slice().concat([i]);
              if (i < value.length) {
                setComments.a[i] = [c.b, c.a];
                merge(c.x, value[i], dropped, kpath);
              } else {
                dropped.push(droppedComment(kpath, c));
                dropAll(c.x, dropped, kpath);
              }
            }
          }
        }
        if (i === 0 && comments.e)
          setComments.e = [comments.e.b, comments.e.a];
      } else {
        setComments.c = {};
        setComments.o = [];
        (comments.o || []).forEach(function(key2) {
          var kpath2 = path.slice().concat([key2]);
          var c2 = comments.s[key2];
          if (Object.prototype.hasOwnProperty.call(value, key2)) {
            setComments.o.push(key2);
            if (c2) {
              setComments.c[key2] = [c2.b, c2.a];
              merge(c2.x, value[key2], dropped, kpath2);
            }
          } else if (c2) {
            dropped.push(droppedComment(kpath2, c2));
            dropAll(c2.x, dropped, kpath2);
          }
        });
        if (comments.e)
          setComments.e = [comments.e.b, comments.e.a];
      }
    }
    function rootComment(value, setText, header) {
      var comment = common.createComment(value, common.getComment(value));
      if (!comment.r)
        comment.r = ["", ""];
      if (setText || setText === "")
        comment.r[header] = common.forceComment(setText);
      return comment.r[header] || "";
    }
    module.exports = {
      extract: function(value) {
        return extractComments(value, true);
      },
      merge: mergeComments,
      header: function(value, setText) {
        return rootComment(value, setText, 0);
      },
      footer: function(value, setText) {
        return rootComment(value, setText, 1);
      }
    };
  }
});

// node_modules/hjson/lib/hjson.js
var require_hjson = __commonJS({
  "node_modules/hjson/lib/hjson.js"(exports, module) {
    var common = require_hjson_common();
    var version = require_hjson_version();
    var parse = require_hjson_parse();
    var stringify = require_hjson_stringify();
    var comments = require_hjson_comments();
    var dsf = require_hjson_dsf();
    module.exports = {
      parse,
      stringify,
      endOfLine: function() {
        return common.EOL;
      },
      setEndOfLine: function(eol) {
        if (eol === "\n" || eol === "\r\n")
          common.EOL = eol;
      },
      version,
      // round trip shortcut
      rt: {
        parse: function(text, options) {
          (options = options || {}).keepWsc = true;
          return parse(text, options);
        },
        stringify: function(value, options) {
          (options = options || {}).keepWsc = true;
          return stringify(value, options);
        }
      },
      comments,
      dsf: dsf.std
    };
  }
});
export default require_hjson();
/*! Bundled license information:

hjson/lib/hjson.js:
  (*!
   * Hjson v3.2.1
   * https://hjson.github.io
   *
   * Copyright 2014-2017 Christian Zangl, MIT license
   * Details and documentation:
   * https://github.com/hjson/hjson-js
   *
   * This code is based on the the JSON version by Douglas Crockford:
   * https://github.com/douglascrockford/JSON-js (json_parse.js, json2.js)
   *)
*/
//# sourceMappingURL=hjson.js.map
